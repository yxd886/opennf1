diff -urN prads/etc/prads.conf prads-sdmbn/etc/prads.conf
--- prads/etc/prads.conf	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/etc/prads.conf	2013-05-17 13:31:45.000000003 -0500
@@ -148,7 +148,7 @@
 ## -------------------------
 ## This is the username prads-archiver will run as when started as root.
 ## Default is to drop to uid 1 which corresponds to user daemon on most systems
-#user=daemon
+user=root
 #
 ## group
 ## -------------------------
diff -urN prads/.gitignore prads-sdmbn/.gitignore
--- prads/.gitignore	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/.gitignore	2013-05-10 11:26:46.000000003 -0500
@@ -1 +1,8 @@
 *.o
+prads-asset.log
+src/prads
+src/shm-client
+doc/prads-asset-report.1.gz
+doc/prads-wirefuzz.1.gz
+doc/prads.1.gz
+doc/prads2snort.1.gz
diff -urN prads/Makefile prads-sdmbn/Makefile
--- prads/Makefile	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/Makefile	2014-02-17 17:20:12.000000003 -0600
@@ -1,9 +1,16 @@
+ifeq (${PREFIX},)
 PREFIX=/usr/local
+endif
 BINDIR=${PREFIX}/bin
 CONFDIR=${PREFIX}/etc/prads
 MANDIR=${PREFIX}/share/man/man1
 DOCUTIL=rst2man
+ifeq (${INSTALLUSER},)
+INSTALLUSER=root
+endif
+ifeq (${INSTALLGROUP},)
 INSTALLGROUP=root
+endif
 
 ifeq ($(UNAME), FreeBSD)
 DOCUTIL=rst2man.py
@@ -33,42 +40,42 @@
 install: man
 	# binaries
 	install -d ${DESTDIR}${BINDIR}
-	install -m 755 -o root -g ${INSTALLGROUP} src/prads ${DESTDIR}${BINDIR}/prads
-	install -m 755 -o root -g ${INSTALLGROUP} tools/prads-asset-report ${DESTDIR}${BINDIR}/prads-asset-report
-	install -m 755 -o root -g ${INSTALLGROUP} tools/prads2snort ${DESTDIR}${BINDIR}/prads2snort
+	install -m 755 -o ${INSTALLUSER} -g ${INSTALLGROUP} src/prads ${DESTDIR}${BINDIR}/prads
+	install -m 755 -o ${INSTALLUSER} -g ${INSTALLGROUP} tools/prads-asset-report ${DESTDIR}${BINDIR}/prads-asset-report
+	install -m 755 -o ${INSTALLUSER} -g ${INSTALLGROUP} tools/prads2snort ${DESTDIR}${BINDIR}/prads2snort
 	# config
 	install -d ${DESTDIR}${CONFDIR}
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/prads.conf ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/prads.conf ${DESTDIR}${CONFDIR}/
 	# fingerprints
-	#install -m 644 -o root -g ${INSTALLGROUP} etc/osi.fp ${DESTDIR}${CONFDIR}/
-	#install -m 644 -o root -g ${INSTALLGROUP} etc/oso.fp ${DESTDIR}${CONFDIR}/
-	#install -m 644 -o root -g ${INSTALLGROUP} etc/osu.fp ${DESTDIR}${CONFDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} etc/tcp-syn.fp ${DESTDIR}${CONFDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} etc/tcp-synack.fp ${DESTDIR}${CONFDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} etc/tcp-fin.fp ${DESTDIR}${CONFDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} etc/tcp-rst.fp ${DESTDIR}${CONFDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} etc/tcp-stray-ack.fp ${DESTDIR}${CONFDIR}/
+	#install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/osi.fp ${DESTDIR}${CONFDIR}/
+	#install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/oso.fp ${DESTDIR}${CONFDIR}/
+	#install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/osu.fp ${DESTDIR}${CONFDIR}/
+	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-syn.fp ${DESTDIR}${CONFDIR}/
+	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-synack.fp ${DESTDIR}${CONFDIR}/
+	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-fin.fp ${DESTDIR}${CONFDIR}/
+	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-rst.fp ${DESTDIR}${CONFDIR}/
+	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-stray-ack.fp ${DESTDIR}${CONFDIR}/
 	# signatures
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/eth.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/icmp-data.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/mac.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/mtu.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/os.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/tcp-clients.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/tcp-service.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/udp-service.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/service-string.sig ${DESTDIR}${CONFDIR}/
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/web-application.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/eth.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/icmp-data.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/mac.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/mtu.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/os.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-clients.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/tcp-service.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/udp-service.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/service-string.sig ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/web-application.sig ${DESTDIR}${CONFDIR}/
 	# ports 
 	install -d ${DESTDIR}${CONFDIR}
-	install -C -m 644 -o root -g ${INSTALLGROUP} etc/udp.ports ${DESTDIR}${CONFDIR}/
+	install -C -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} etc/udp.ports ${DESTDIR}${CONFDIR}/
 	install -d ${DESTDIR}${CONFDIR}/init.d
-	install -m 755 -o root -g ${INSTALLGROUP} doc/prads.rc ${DESTDIR}${CONFDIR}/init.d/
+	install -m 755 -o ${INSTALLUSER} -g ${INSTALLGROUP} doc/prads.rc ${DESTDIR}${CONFDIR}/init.d/
 	# man pages
-	install -d ${DESTDIR}${MANDIR}
-	install -m 644 -o root -g ${INSTALLGROUP} doc/prads.1.gz ${DESTDIR}${MANDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} doc/prads-asset-report.1.gz ${DESTDIR}${MANDIR}/
-	install -m 644 -o root -g ${INSTALLGROUP} doc/prads2snort.1.gz ${DESTDIR}${MANDIR}/
+#	install -d ${DESTDIR}${MANDIR}
+#	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} doc/prads.1.gz ${DESTDIR}${MANDIR}/
+#	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} doc/prads-asset-report.1.gz ${DESTDIR}${MANDIR}/
+#	install -m 644 -o ${INSTALLUSER} -g ${INSTALLGROUP} doc/prads2snort.1.gz ${DESTDIR}${MANDIR}/
 
 
 .PHONY: build clean install
diff -urN prads/README prads-sdmbn/README
--- prads/README	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/README	2014-02-17 17:20:12.000000003 -0600
@@ -58,3 +58,12 @@
 # SQL database, WebGUI etc.
 This is on the agenda. There will be a webgui to the database, for easy browsing of your network. 
 
+============================
+OpenNF Support
+============================
+
+This code base has been modified by researchers at the University of
+Wisconsin-Madison to support OpenNF. See the OpenNF home page for more
+information:
+
+    http://pages.cs.wisc.edu/~agember/opennf
diff -urN prads/sdmbn_build.sh prads-sdmbn/sdmbn_build.sh
--- prads/sdmbn_build.sh	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/sdmbn_build.sh	2014-02-17 17:20:12.000000003 -0600
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+make
+make install
diff -urN prads/SOURCE prads-sdmbn/SOURCE
--- prads/SOURCE	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/SOURCE	2013-05-10 11:26:07.000000003 -0500
@@ -0,0 +1,2 @@
+https://github.com/gamelinux/prads.git
+930ff5140aa90259ec02b85fdd8ba69f9c0c5c64
diff -urN prads/src/assets.c prads-sdmbn/src/assets.c
--- prads/src/assets.c	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/assets.c	2014-04-25 15:16:28.000000003 -0500
@@ -1,3 +1,5 @@
+#include <sys/time.h>
+#include <string.h>
 #include "common.h"
 #include "prads.h"
 #include "assets.h"
@@ -5,16 +7,24 @@
 #include "output-plugins/log.h"
 #include "config.h"
 #include "mac.h"
+#include <SDMBN.h>
+#include "SDMBNLocal.h"
 
 extern globalconfig config;
 static asset *passet[BUCKET_SIZE];
 
+long overall_mserz_time = 0;
+long overall_mdeserz_time = 0;
+long overall_mstate_size = 0;
+
 void update_asset(packetinfo *pi)
 {
     if (asset_lookup(pi) == SUCCESS) {
         if (pi->asset != NULL) {
+            pthread_mutex_lock(&AssetEntryLock);
             pi->asset->vlan = pi->vlan;
             pi->asset->last_seen = pi->pheader->ts.tv_sec;
+            pthread_mutex_unlock(&AssetEntryLock);
         } else {
             printf("\nBAD ERROR in update_asset\n");
         }
@@ -86,6 +96,262 @@
    }
 }
 
+///// SDMBN Support Functions ///////////////////////////////////////////////
+asset* get_asset_per_sip(uint32_t sip)
+{
+    uint64_t hash;
+    asset *masset = NULL;
+     
+    hash = ASSET_HASH4(sip);
+    pthread_mutex_lock(&AssetEntryLock);        
+    masset = passet[hash];
+    while (masset != NULL) {
+        if (masset->af == AF_INET && CMP_ADDR4( &masset->ip_addr, sip))
+        {
+            INFO_PRINT("get asset_per_sp %d", masset->vlan);
+            /*if (curr != NULL && state != NULL)
+            {
+                curr->c_asset = masset;
+                *state = ser_ialize(head_tra, "connection", curr, NULL, 0);
+            }*/
+            pthread_mutex_unlock(&AssetEntryLock); 
+            return masset;
+        }
+        masset = masset->next;
+    }
+    
+    pthread_mutex_unlock(&AssetEntryLock); 
+    return masset;
+}
+
+void update_osassets_per_asset(asset *l_asset, asset *in_asset, 
+        connection *cxt)
+{
+    os_asset *tmp_oa = NULL;
+    os_asset *head_oa = NULL;
+    os_asset *in_oa = NULL;
+    tmp_oa = l_asset->os;
+    head_oa = l_asset->os;
+    in_oa = in_asset->os;
+    while (in_oa)
+    {
+        while (tmp_oa != NULL) 
+        {
+            if (in_oa->detection == tmp_oa->detection) 
+            {
+                if (in_oa->raw_fp) 
+                {
+                    // old style save-the-fp-string OS detection
+                    if (biseq(in_oa->raw_fp, tmp_oa->raw_fp) == 1) 
+                    {
+                        /* Found! */
+                        // FIXME: inefficient string copies
+                        bdestroy(tmp_oa->raw_fp);
+                        tmp_oa->raw_fp = bstrcpy(in_oa->raw_fp);
+                        //tmp_sa->i_attempts++;
+                        tmp_oa->port = in_oa->port;
+                        tmp_oa->last_seen = in_oa->last_seen;
+                        tmp_oa->uptime = in_oa->uptime;
+                        break;
+                    }
+                }
+		// [TODO]Fix this
+                /*else if (in_oa->fp)
+                {
+                    if (in_oa->fp.os == tmp_oa->fp.os &&
+                        in_oa->fp.desc == tmp_oa->fp.desc){
+                        // pointer equality - does this OS asset point
+                        // to the same match?
+                        //if (match == tmp_oa->match) {
+                        tmp_oa->port = in_oa->port;
+                        tmp_oa->last_seen = in_oa->last_seen;
+                        tmp_oa->uptime = in_oa->uptime;
+                        break;
+                }*/
+            }
+            tmp_oa = tmp_oa->next;
+        }
+
+        if (tmp_oa == NULL) 
+        {
+            //update_os_stats(detection);
+            os_asset *new_oa = NULL;
+
+            // FIXME: allocate resource from shared storage pool
+            new_oa = (os_asset *) calloc(1, sizeof(os_asset));
+            new_oa->detection = in_oa->detection;
+
+            if (in_oa->raw_fp) 
+            {
+                // FIXME: don't copy fp, bincode it
+                new_oa->raw_fp = bstrcpy(in_oa->raw_fp);
+            } 
+            /*else if(in_oa->fp) 
+            {
+                // copy the match
+                new_oa->fp = in_oa->fp;
+                //new_oa->fp = *match; //why copy it two times?
+            }*/
+            //new_oa->i_attempts = 1;
+            new_oa->first_seen = in_oa->first_seen;
+            new_oa->last_seen = in_oa->last_seen;
+            new_oa->port = in_oa->port;
+            new_oa->ttl = in_oa->ttl;
+            new_oa->uptime = in_oa->uptime;
+            new_oa->next = head_oa;
+            if (head_oa != NULL)
+            { head_oa->prev = new_oa; }
+            new_oa->prev = NULL;
+            l_asset->os = new_oa;
+
+            if (cxt != NULL)
+            { log_asset_os(l_asset,new_oa,cxt); }
+        }
+        in_oa = in_oa->next;
+    }
+}
+
+void update_sassets_per_asset(asset *l_asset, asset *in_asset, 
+        connection *cxt)
+{
+    serv_asset *tmp_sa = NULL;
+    serv_asset *head_sa = NULL;
+    serv_asset *in_sa = NULL;
+    uint16_t port;
+
+    in_sa = in_asset->services;
+    while (in_sa)
+    {
+         /* Find asset within linked list */
+         tmp_sa = head_sa = l_asset->services;
+         port = in_sa->port;
+ 
+         while (tmp_sa != NULL) 
+         {
+             if (in_sa->port == tmp_sa->port 
+                     && in_sa->proto == tmp_sa->proto) 
+             {
+                 if (in_sa->last_seen < tmp_sa->last_seen)
+                 { break; }
+                
+                 if ((in_sa->application->data[0] != '@') 
+                         && (tmp_sa->application->data[0] == '@')) 
+                 {
+                     tmp_sa->i_attempts = 0;
+                     bdestroy(tmp_sa->service);
+                     bdestroy(tmp_sa->application);
+                     tmp_sa->service = bstrcpy(in_sa->service);
+                     tmp_sa->application = bstrcpy(in_sa->application);
+                     tmp_sa->last_seen = in_sa->last_seen;
+
+                     log_asset_service(l_asset,tmp_sa, cxt);
+                     
+                 } 
+                 else if (!(biseq(in_sa->application, tmp_sa->application) 
+                             == 1)) 
+                 {
+                     if (tmp_sa->i_attempts > MAX_SERVICE_CHECK) 
+                     {
+                         tmp_sa->i_attempts = 0;
+                         bdestroy(tmp_sa->service);
+                         bdestroy(tmp_sa->application);
+                         tmp_sa->service = bstrcpy(in_sa->service);
+                         tmp_sa->application = bstrcpy(in_sa->application);
+                         tmp_sa->last_seen = in_sa->last_seen;
+                         log_asset_service(l_asset,tmp_sa, cxt);
+                     } 
+                     else 
+                     {
+                        tmp_sa->i_attempts++;
+                        tmp_sa->last_seen = in_sa->last_seen;
+                     }
+                } 
+                else 
+                {
+                    tmp_sa->i_attempts = 0;
+                    tmp_sa->last_seen = in_sa->last_seen;
+                    
+                }
+                break;
+            }
+            tmp_sa = tmp_sa->next;
+        }
+
+        if (tmp_sa == NULL) 
+        {
+            // update_service_stats(pi->sc, pi->proto);
+            serv_asset *new_sa = NULL;
+            new_sa = (serv_asset *) calloc(1, sizeof(serv_asset));
+            new_sa->port = in_sa->port;
+            new_sa->ttl = in_sa->ttl;
+            new_sa->proto = in_sa->proto;
+            new_sa->service = bstrcpy(in_sa->service);
+            new_sa->application = bstrcpy(in_sa->application);
+            new_sa->role = in_sa->role;
+            new_sa->i_attempts = in_sa->i_attempts;
+            new_sa->first_seen = in_sa->first_seen;
+            new_sa->last_seen = in_sa->last_seen;
+            new_sa->next = l_asset->services;
+            new_sa->prev = NULL;
+            l_asset->services = new_sa;
+
+            if (cxt != NULL)
+            { log_asset_service(l_asset, new_sa, cxt); }
+        }
+        in_sa = in_sa->next; 
+    }
+}
+
+void put_asset_per_sip(uint32_t sip, asset* in_asset, connection *cxt)
+{
+    asset *l_asset = NULL, *temp_asset = NULL;
+    char *temp;
+
+    if (in_asset == NULL)
+    { return; }
+
+    l_asset = get_asset_per_sip(sip);
+    in_asset->next = NULL;
+    in_asset->prev = NULL;
+    INFO_PRINT("[put_asset_per_sip]: Putting asset in the list..for IP %d",
+            sip); 
+    if (l_asset == NULL)
+    {
+        // Asset struct not found
+        // Push the struct into the list
+        INFO_PRINT("[put_asset_per_sip]: Asset structure not found"); 
+        uint64_t hash;
+        pthread_mutex_lock(&AssetEntryLock);
+        hash = ASSET_HASH4(sip);
+        in_asset->next = passet[hash];
+
+        if (passet[hash] != NULL)
+        { passet[hash]->prev = in_asset; }
+    
+        passet[hash] = in_asset;
+        in_asset->ref = 0;
+        
+        pthread_mutex_unlock(&AssetEntryLock); 
+        return;
+    }
+    
+    // Asset struct found update
+    // Update the structs if required
+    INFO_PRINT("[put_asset_per_sip]: Asset structure found");
+    if (l_asset->last_seen > in_asset->last_seen)
+    { return; }
+
+    l_asset->vlan = in_asset->vlan;
+    l_asset->last_seen = in_asset->last_seen;
+     
+    INFO_PRINT("[put_asset_per_sip]: Updating OS and Service Assets");
+    update_sassets_per_asset(l_asset, in_asset, cxt);
+    update_osassets_per_asset(l_asset, in_asset, cxt);
+    // Delete the asset as the deltas have now been logged
+    del_asset(in_asset, &temp_asset);
+}
+/////////////////////////////////////////////////////////////////////////////
+
 asset* connection_lookup(packetinfo *pi)
 {
    if(NULL == pi->cxt){
@@ -103,6 +369,28 @@
    }
    return NULL;
 }
+
+///// SDMBN Support Functions ///////////////////////////////////////////////
+void update_cxt_asset(packetinfo *pi, asset *masset)
+{
+   if(NULL == pi->cxt)
+   {
+      INFO_PRINT("[update_cxt_asset] pi->cxt is Null");
+      return;
+   }
+   INFO_PRINT("[update_cxt_asset] Updating cxt asset");
+   if (pi->sc == SC_CLIENT && pi->cxt->reversed == 0 ) 
+   { pi->cxt->c_asset = masset; }
+   else if (pi->sc == SC_CLIENT && pi->cxt->reversed == 1 ) 
+   { pi->cxt->s_asset = masset; }
+   else if (pi->sc == SC_SERVER && pi->cxt->reversed == 0 )
+   { pi->cxt->s_asset = masset; }
+   else if (pi->sc == SC_SERVER && pi->cxt->reversed == 1 )
+   { pi->cxt->c_asset = masset; }
+   __sync_fetch_and_add(&masset->ref,1); // take a ref for cxt
+}
+/////////////////////////////////////////////////////////////////////////////
+
 /* asset *asset_lookup(struct in6_addr ip, int af)
  * tries to match your packet to a sender we've seen before
  * 
@@ -130,6 +418,7 @@
                 ip = PI_IP4SRC(pi);
             }
             hash = ASSET_HASH4(ip);
+            pthread_mutex_lock(&AssetEntryLock); 
             masset = passet[hash];
             while (masset != NULL) {
                 //if (memcmp(&ip_addr,&rec->ip_addr,16)) {
@@ -137,22 +426,28 @@
                     && CMP_ADDR4( &masset->ip_addr, ip))
                 {
                     pi->asset = masset;
+                    update_cxt_asset(pi,masset);
+                    pthread_mutex_unlock(&AssetEntryLock);
                     return SUCCESS;
                 }
                 masset = masset->next;
             }
+            pthread_mutex_unlock(&AssetEntryLock); 
             return ERROR;
         } else if (pi->af == AF_INET6) {
             hash = ASSET_HASH6(PI_IP6SRC(pi));
+            pthread_mutex_lock(&AssetEntryLock);
             masset = passet[hash];
             while (masset != NULL) {
                 if (masset->af == AF_INET6 &&
                     CMP_ADDR6(&masset->ip_addr, &PI_IP6SRC(pi))){
                     pi->asset = masset;
+                    pthread_mutex_unlock(&AssetEntryLock); 
                     return SUCCESS;
                 }
                 masset = masset->next;
             }
+            pthread_mutex_unlock(&AssetEntryLock); 
             return ERROR;
         }
         return ERROR;
@@ -250,7 +545,7 @@
             }else if (match){
                 // pointer equality - does this OS asset point
                 // to the same match?
-                if (match->os == tmp_oa->fp.os &&
+                /*if (match->os == tmp_oa->fp.os &&
                     match->desc == tmp_oa->fp.desc){
                 //if (match == tmp_oa->match) {
 
@@ -263,7 +558,7 @@
                     if (uptime)
                         tmp_oa->uptime = uptime;
                     return SUCCESS;
-                }
+                }*/
             }
         }
         tmp_oa = tmp_oa->next;
@@ -458,6 +753,7 @@
         hash = ASSET_HASH6(PI_IP6SRC(pi));
     }
 
+    pthread_mutex_lock(&AssetEntryLock); 
     masset->next = passet[hash];
 
     if (passet[hash] != NULL)
@@ -467,6 +763,8 @@
     masset->services = NULL;
     masset->macentry = NULL;
     passet[hash] = masset;
+    pthread_mutex_unlock(&AssetEntryLock); 
+    update_cxt_asset(pi, masset);
 
 #ifdef DEBUGG
     /* verbose info for sanity checking */
@@ -686,6 +984,7 @@
     asset *rec = NULL;
     int akey;
 
+    pthread_mutex_lock(&AssetEntryLock); 
     for (akey = 0; akey < BUCKET_SIZE; akey++) {
         rec = passet[akey];
         while (rec != NULL) {
@@ -714,6 +1013,7 @@
             del_asset(tmp, &passet[akey]);
         }
     }
+    pthread_mutex_unlock(&AssetEntryLock); 
     dlog("asset memory has been cleared\n");
 }
 
@@ -732,6 +1032,7 @@
     serv_asset *tmp_sa = NULL;
     os_asset *tmp_oa = NULL;
 
+    pthread_mutex_lock(&AssetEntryLock); 
     for (akey = 0; akey < BUCKET_SIZE; akey++) {
         rec = passet[akey];
         while (rec != NULL) {
@@ -782,4 +1083,285 @@
             }
         }
     }
+    pthread_mutex_unlock(&AssetEntryLock); 
+}
+
+///// SDMBN Local Multiflow State Handlers ///////////////////////////////////
+int local_get_multiflow(PerflowKey *key, int id)
+{
+    int count = 0;
+    // Return multiflow state for a specific key
+    if (key != NULL)
+    {
+        uint64_t hash;
+        char *state;
+        //asset* ast = NULL;
+        asset *masset = NULL;
+        
+	// Check nw_src -- must be present to get specific key
+        if (key->wildcards & WILDCARD_NW_SRC)
+        { goto all; }
+     
+        //INFO_PRINT("Getting the asset for IP %d", key->nw_src);
+        hash = ASSET_HASH4(key->nw_src);
+
+        pthread_mutex_lock(&AssetEntryLock); 
+        masset = passet[hash];
+        while (masset != NULL) 
+        {
+        	if (masset->af == AF_INET 
+       		    && CMP_ADDR4( &masset->ip_addr, key->nw_src))
+        	{
+	            INFO_PRINT("Found %d", masset->vlan);
+       		    break;
+        	}
+        	masset = masset->next;
+        }
+        pthread_mutex_unlock(&AssetEntryLock); 	
+        // No Asset found with the input key
+        if (masset == NULL)
+        { return 0; }
+        
+        struct timeval start_serialize, end_serialize;
+        gettimeofday(&start_serialize, NULL);
+
+        state = ser_ialize(head_tra, "asset", masset, NULL, 0);
+        //char *state = ser_ialize(head_tra, "asset", ast, NULL, 0);
+        //pthread_rwlock_unlock(&rwlock);
+        gettimeofday(&end_serialize, NULL);
+		long sec = end_serialize.tv_sec - start_serialize.tv_sec;
+		long usec = end_serialize.tv_usec - start_serialize.tv_usec;
+		long total = (sec * 1000 * 1000) + usec;
+		overall_mserz_time += total;
+		overall_mstate_size += strlen(state);
+		printf("STATS: MULTIFLOW STATE SIZE CURRENT = %zu\n", strlen(state));
+		printf("STATS: MULTIFLOW STATE SIZE OVERALL = %zu\n", overall_mstate_size);
+		printf("STATS: MULTIFLOW: TIME TO SERIALIZE CURRENT = %ldus\n", total);
+		printf("STATS: MULTIFLOW: TIME TO SERIALIZE OVERALL = %ldus\n", overall_mserz_time);
+
+        SERIALIZE_PRINT("serializing multi flow state\n%s", state);
+
+        // Construct key
+        PerflowKey astkey;
+        astkey.wildcards = WILDCARD_ALL;
+        if (AF_INET == masset->af)
+        {
+            astkey.dl_type = 0x0800;
+            astkey.nw_src = masset->ip_addr.s6_addr32[0];
+            astkey.wildcards &= ~(WILDCARD_NW_SRC | WILDCARD_DL_TYPE);
+        }
+        else
+        { /* FIXME: Handle IPv6 */ }
+        int hashkey = astkey.nw_src;
+
+        // Send multiflow state
+        int result = sdmbn_send_multiflow(id, &astkey, state, hashkey, count);
+        if (result < 0)
+        { }
+
+        // Increment count
+        count++;
+
+        // Clean-up
+        free(state);
+        return count;
+    }
+	else
+		return -1;
+    //INFO_PRINT("multiflow key is NULL");
+all:
+	printf("SRC_IP is wildcarded, getting all multiflow states");
+    int h = 0;
+    for (h = 0; h < BUCKET_SIZE; h++)
+    {
+        pthread_mutex_lock(&AssetEntryLock); 
+        asset *curr = passet[h];
+        while (curr != NULL)
+        {
+
+        	 struct timeval start_serialize, end_serialize;
+        	 gettimeofday(&start_serialize, NULL);
+
+
+            //pthread_rwlock_wrlock(&rwlock);
+            char *state = ser_ialize(head_tra, "asset", curr, NULL, 0);
+            //pthread_rwlock_unlock(&rwlock);
+
+            gettimeofday(&end_serialize, NULL);
+			long sec = end_serialize.tv_sec - start_serialize.tv_sec;
+			long usec = end_serialize.tv_usec - start_serialize.tv_usec;
+			long total = (sec * 1000 * 1000) + usec;
+			overall_mserz_time += total;
+			overall_mstate_size += strlen(state);
+			printf("STATS: MULTIFLOW STATE SIZE CURRENT = %zu\n", strlen(state));
+			printf("STATS: MULTIFLOW STATE SIZE OVERALL = %zu\n", overall_mstate_size);
+			printf("STATS: MULTIFLOW: TIME TO SERIALIZE CURRENT = %ldus\n", total);
+			printf("STATS: MULTIFLOW: TIME TO SERIALIZE OVERALL = %ldus\n", overall_mserz_time);
+
+            // Construct key
+            PerflowKey astkey;
+            astkey.wildcards = WILDCARD_ALL;
+            if (AF_INET == curr->af)
+            {
+                astkey.dl_type = 0x0800;
+                astkey.nw_src = curr->ip_addr.s6_addr32[0];
+                astkey.wildcards &= ~(WILDCARD_NW_SRC | WILDCARD_DL_TYPE);
+            }
+            else
+            { /* FIXME: Handle IPv6 */ }
+            int hashkey = astkey.nw_src;
+
+            // Send multiflow state
+            int result = sdmbn_send_multiflow(id, &astkey, state, hashkey, 
+                    count);
+            if (result < 0)
+            { }
+
+            // Clean-up
+            free(state);
+
+            // Increment count
+            count++;
+
+            // Move on to next asset
+            curr = curr->next;
+        }
+        pthread_mutex_unlock(&AssetEntryLock); 
+    }
+
+    return count;
+}
+
+int local_put_multiflow(int hashkey, PerflowKey *key, char *state)
+{
+    if (NULL == key || NULL == state)
+    { return -1; }
+
+    SERIALIZE_PRINT("deserializing multi flow state\n%s", state);
+
+    struct timeval start_deserialize, end_deserialize;
+    gettimeofday(&start_deserialize, NULL);
+
+    asset *ast = ser_parse(head_tra, "asset", state, NULL);
+    gettimeofday(&end_deserialize, NULL);
+	long sec = end_deserialize.tv_sec - start_deserialize.tv_sec;
+	long usec = end_deserialize.tv_usec - start_deserialize.tv_usec;
+	long total = (sec * 1000 * 1000) + usec;
+	overall_mdeserz_time += total;
+	printf("STATS: MULTIFLOW: TIME TO DESERIALIZE CURRENT = %ldus\n", total);
+	printf("STATS: MULTIFLOW: TIME TO DESERIALIZE OVERALL = %ldus\n", overall_mdeserz_time);
+
+    put_asset_per_sip(key->nw_src, ast, NULL);     
+
+    return 1;
+}
+
+int del_all_multiflows()
+{
+    //INFO_PRINT("Clear Asset");
+    int count = 0;
+    asset *rec = NULL;
+    int akey;
+    pthread_mutex_lock(&AssetEntryLock);
+    for (akey = 0; akey < BUCKET_SIZE; akey++) 
+    {
+        rec = passet[akey];
+        while (rec != NULL) 
+        {
+            //if (!force && rec->ref > 0)
+            //    continue;
+            serv_asset *tmp_sa = NULL;
+            os_asset   *tmp_oa = NULL;
+            tmp_sa = rec->services;
+            tmp_oa = rec->os;
+
+            while (tmp_sa != NULL) 
+            {
+                // Delete service asset
+                serv_asset *stmp = tmp_sa;
+                tmp_sa = tmp_sa->next;
+                del_serv_asset(&rec->services, stmp);
+            }
+
+            while (tmp_oa != NULL) 
+            {
+                // Delete os asset
+                os_asset *otmp = tmp_oa;
+                tmp_oa = tmp_oa->next;
+                del_os_asset(&rec->os, otmp);
+            }
+
+            // Delete the main asset
+            asset *tmp = rec;
+            rec = rec->next;
+            del_asset(tmp, &passet[akey]);
+            count++;
+        }
+    }
+    pthread_mutex_unlock(&AssetEntryLock);
+    dlog("asset memory has been cleared\n");
+    return count;
+}
+
+int find_del_asset(asset *masset)
+{
+    uint32_t sip;
+    uint64_t hash;
+    if (masset == NULL)
+    { return 0; }
+    sip = IP4ADDR(&masset->ip_addr);
+    if (sip == 0)
+    { return 0; }
+    if (masset->ref > 0)
+    { return 0; }
+
+    hash = ASSET_HASH4(sip);
+    // Clean-up
+    pthread_mutex_lock(&AssetEntryLock);  
+    del_asset(masset,&passet[hash]);
+    pthread_mutex_unlock(&AssetEntryLock);
+    return 1;
 }
+
+char* serialize_conn_asset(connection *conn, int msgid)
+{ 
+    asset *c_asset = NULL, *s_asset = NULL;
+
+    c_asset = conn->c_asset;
+    s_asset = conn->s_asset;
+    pthread_mutex_lock(&AssetEntryLock);  
+    if (c_asset != NULL)
+    {
+    	if (c_asset->sdmbn_msgid == msgid)
+        {
+            // temp set the conn->c_asset to NULL
+            // to avoid retransmitting the same asset struct
+            conn->c_asset = NULL; 
+        }
+        c_asset->sdmbn_msgid = msgid;
+    }
+
+    if (s_asset != NULL)
+    {
+        if (s_asset->sdmbn_msgid == msgid)
+        {
+            // temp set the conn->s_asset to NULL
+            // to avoid retransmitting the same asset struct
+            conn->s_asset = NULL;
+        }
+        s_asset->sdmbn_msgid = msgid;
+    }
+
+    char *state = ser_ialize(head_tra, "connection", conn, NULL, 0);
+    // restore the asset pointers
+    conn->c_asset = c_asset;
+    conn->s_asset = s_asset;
+    pthread_mutex_unlock(&AssetEntryLock); 
+    return state;
+}
+
+int decr_asset_ref(asset *masset)
+{ return __sync_sub_and_fetch(&masset->ref,1); }
+
+int incr_asset_ref(asset *masset)
+{ return __sync_add_and_fetch(&masset->ref,1); }
diff -urN prads/src/assets.h prads-sdmbn/src/assets.h
--- prads/src/assets.h	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/assets.h	2014-02-17 17:20:12.000000003 -0600
@@ -1,3 +1,4 @@
+#include "SDMBN.h"
 #define ASSET_HASH4(ip) ((ip) % BUCKET_SIZE)
 
 #define ASSET_HASH6(ip) ( (ip).s6_addr32[3] % BUCKET_SIZE )
@@ -14,3 +15,10 @@
 void update_asset_list();
 void update_service_stats(int role, uint16_t proto);
 uint8_t asset_lookup(packetinfo *pi);
+asset* get_asset_per_sip(uint32_t sip);
+void put_asset_per_sip(uint32_t sip, asset* in_asset, connection *cxt);
+char* serialize_conn_asset(connection *conn, int msgid);
+int find_del_asset(asset *masset);
+int decr_asset_ref(asset *masset);
+int incr_asset_ref(asset *masset);
+int del_all_multiflows();
diff -urN prads/src/config.c prads-sdmbn/src/config.c
--- prads/src/config.c	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/config.c	2014-03-31 14:12:01.000000003 -0500
@@ -519,6 +519,9 @@
         case '?':
             elog("unrecognized argument: '%c'\n", optopt);
             break;
+        case 'w':
+            conf->writeiface = strdup(optarg);
+            break;
         default:
             elog("Did not recognize argument '%c'\n", ch);
         }
diff -urN prads/src/config.h prads-sdmbn/src/config.h
--- prads/src/config.h	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/config.h	2014-03-31 14:12:01.000000003 -0500
@@ -98,6 +98,8 @@
     mac_entry  **sig_mac;               /* Pointer to hash of mac signatures */
     dhcp_fp_entry **sig_dhcp;           /* DHCP signature hash */
     char        *bpf_file;              /* filename of BPF file to load */
+    char        *writeiface;            /* Interface to write packets */
+    pcap_t      *live;                  /* PCAP handle for writing packets */
 } globalconfig;
 #define ISSET_CONFIG_VERBOSE(config)    ((config).cflags & CONFIG_VERBOSE)
 #define ISSET_CONFIG_UPDATES(config)    ((config).cflags & CONFIG_UPDATES)
diff -urN prads/src/cxt.c prads-sdmbn/src/cxt.c
--- prads/src/cxt.c	2013-11-06 10:14:02.000000003 -0600
+++ prads-sdmbn/src/cxt.c	2014-04-25 15:01:18.000000003 -0500
@@ -1,16 +1,28 @@
 #include <assert.h>
+#include <sys/time.h>
+#include <string.h>
 #include "common.h"
 #include "prads.h"
 #include "cxt.h"
 #include "sys_func.h"
 #include "config.h"
 #include "output-plugins/log.h"
+#include <SDMBN.h>
+#include "SDMBNLocal.h"
+#include "serialize.h"
+#include "assets.h"
+
+static void local_raise_reprocess(connection *cxt, packetinfo *pi);
 
 extern globalconfig config;
 
 uint64_t cxtrackerid;
 connection *bucket[BUCKET_SIZE];
 
+long overall_pserz_time = 0;
+long overall_pdeserz_time = 0;
+long overall_pstate_size = 0;
+
 void cxt_init()
 {
     cxtrackerid = 0;
@@ -27,6 +39,8 @@
     assert(cxt);
     cxt->cxid = cxtrackerid;
 
+    sdmbn_notify_flow_created();
+
     cxt->af = pi->af;
     if(pi->tcph) cxt->s_tcpFlags = pi->tcph->t_flags;
     //cxt->s_tcpFlags |= (pi->tcph ? pi->tcph->t_flags : 0x00);//why??
@@ -73,16 +87,25 @@
 
 int cxt_update_client(connection *cxt, packetinfo *pi)
 {
-    cxt->last_pkt_time = pi->pheader->ts.tv_sec;
-
-    if(pi->tcph) cxt->s_tcpFlags |= pi->tcph->t_flags;
-    cxt->s_total_bytes += pi->packet_bytes;
-    cxt->s_total_pkts += 1;
+    if(cxt->gotten <= 0) {
+      /* process as normal packet, update everything in context */
+      cxt->last_pkt_time = pi->pheader->ts.tv_sec;
+  
+      if(pi->tcph) cxt->s_tcpFlags |= pi->tcph->t_flags;
+      cxt->s_total_bytes += pi->packet_bytes;
+      cxt->s_total_pkts += 1;
+      
+      if(!cxt->c_asset)
+          cxt->c_asset = pi->asset; // connection client asset
+    }
+    else {
+      /* touched state that has been moved and hence set to be dropped */
+      pi->drop_flag = true;
+    }
 
     pi->cxt = cxt;
     pi->sc = SC_CLIENT;
-    if(!cxt->c_asset)
-        cxt->c_asset = pi->asset; // connection client asset
+
     if (cxt->s_total_bytes > MAX_BYTE_CHECK
         || cxt->s_total_pkts > MAX_PKT_CHECK) {
         return 0;   // Dont Check!
@@ -92,22 +115,30 @@
 
 int cxt_update_server(connection *cxt, packetinfo *pi)
 {
-    cxt->last_pkt_time = pi->pheader->ts.tv_sec;
-
-    if(pi->tcph) cxt->d_tcpFlags |= pi->tcph->t_flags;
-    cxt->d_total_bytes += pi->packet_bytes;
-    cxt->d_total_pkts += 1;
+    if(cxt->gotten <= 0) {
+      /* state untouched; process as normal packet, update everything in context */
+      cxt->last_pkt_time = pi->pheader->ts.tv_sec;
+  
+      if(pi->tcph) cxt->d_tcpFlags |= pi->tcph->t_flags;
+      cxt->d_total_bytes += pi->packet_bytes;
+      cxt->d_total_pkts += 1;
+      
+      if(!cxt->s_asset)
+          cxt->s_asset = pi->asset; // server asset
+    }
+    else {
+    	/* touched state that has been moved and hence set to be dropped */
+    	pi->drop_flag = true;
+    }
 
     pi->cxt = cxt;
     pi->sc = SC_SERVER;
-    if(!cxt->s_asset)
-        cxt->s_asset = pi->asset; // server asset
+
     if (cxt->d_total_bytes > MAX_BYTE_CHECK
         || cxt->d_total_pkts > MAX_PKT_CHECK) {
         return 0;   // Dont check!
     }
     return SC_SERVER;
-
 }
 
 /* return value: client or server?
@@ -126,7 +157,7 @@
     connection *cxt = NULL;
     connection *head = NULL;
     uint32_t hash;
-
+    int result = 0;
 
     if(af== AF_INET6){
         ip_src = &PI_IP6SRC(pi);
@@ -146,6 +177,8 @@
     } else if (af == AF_INET6) {
         hash = CXT_HASH6(ip_src,ip_dst,src_port,dst_port,pi->proto);
     }
+
+    pthread_mutex_lock(&ConnEntryLock);
     cxt = bucket[hash];
     head = cxt;
 
@@ -155,16 +188,27 @@
         if (af == AF_INET) {
             if (CMP_CXT4(cxt,IP4ADDR(ip_src),src_port,IP4ADDR(ip_dst),dst_port)){
                 // Client sends first packet (TCP/SYN - UDP?) hence this is a client
-                return cxt_update_client(cxt, pi);
+                local_raise_reprocess(cxt, pi);
+                result = cxt_update_client(cxt, pi);
+                pthread_mutex_unlock(&ConnEntryLock);
+                return result;
+
             } else if (CMP_CXT4(cxt,IP4ADDR(ip_dst),dst_port,IP4ADDR(ip_src),src_port)) {
                 // This is a server (Maybe not when we start up but in the long run)
-                return cxt_update_server(cxt, pi);
+                local_raise_reprocess(cxt, pi);
+                result = cxt_update_server(cxt, pi);
+                pthread_mutex_unlock(&ConnEntryLock);
+                return result;
             }
         } else if (af == AF_INET6) {
             if (CMP_CXT6(cxt,ip_src,src_port,ip_dst,dst_port)){
-                return cxt_update_client(cxt, pi);
+                result = cxt_update_client(cxt, pi);
+                pthread_mutex_unlock(&ConnEntryLock);
+                return result;
             } else if (CMP_CXT6(cxt,ip_dst,dst_port,ip_src,src_port)){
-                return cxt_update_server(cxt, pi);
+                result = cxt_update_server(cxt, pi);
+                pthread_mutex_unlock(&ConnEntryLock);
+                return result;
             }
         }
         cxt = cxt->next;
@@ -182,6 +226,7 @@
     bucket[hash] = cxt;
     pi->cxt = cxt;
 
+    pthread_mutex_unlock(&ConnEntryLock);
     /* * Return value should be 1, telling to do client service fingerprinting */
     return 1;
 }
@@ -343,11 +388,16 @@
         next->prev = prev;
     }
 
+    cxt->c_asset = NULL;
+    cxt->s_asset = NULL;
+    
     /*
      * Free and set to NULL 
      */
     free(cxt);
     cxt = NULL;
+
+    sdmbn_notify_flow_destroyed();
 }
 
 void end_all_sessions()
@@ -435,6 +485,7 @@
 
     // add to packetinfo ? dont through int32 around :)
     hash = make_hash(pi);
+    pthread_mutex_lock(&ConnEntryLock);
     cxt = bucket[hash];
     head = cxt;
 
@@ -462,6 +513,7 @@
             //ok
             dlog("[*] Updating src connection: %lu\n",cxt->cxid);
             cxt_update_src(cxt,pi);
+            pthread_mutex_unlock(&ConnEntryLock);
             return;
         }
 
@@ -476,6 +528,7 @@
         if(!(compare.i[0] & compare.i[1])){
             dlog("[*] Updating dst connection: %lu\n",cxt->cxid);
             cxt_update_dst(cxt,pi);
+            pthread_mutex_unlock(&ConnEntryLock);
             return;
         }
         cxt = cxt->next;
@@ -490,10 +543,453 @@
         dlog("[*] New connection: %lu\n",cxt->cxid);
         cxt->next = head;
         bucket[hash] = cxt;
+        pthread_mutex_unlock(&ConnEntryLock);
         return;
     }
+    pthread_mutex_unlock(&ConnEntryLock);
     printf("[*] Error in session tracking...\n");
     exit (1);
 }
 
 #endif
+
+int drop_counter = 0;
+///// SDMBN Local Event Raisers //////////////////////////////////////////////
+static void local_raise_reprocess(connection *cxt, packetinfo *pi)
+{
+	/*
+	 * gotten = 0 => state is not moved; don't raise events and don't increment drop counter
+	 * gotten = -1 => state is moved but get was called with raiseEvents=0; so don't raise events but update drop counter
+	 * gotten > 0 => state is moved and get was called with raiseEvents=1; so raise events and update drop counter
+	 */
+    if (!(cxt->gotten))
+    {
+        return; 
+    }
+    // event needs to raise or the packet dropped
+    drop_counter++;
+    printf("[SIGMOVE] Drops/Events counter = %d\n", drop_counter);
+
+    if (cxt->gotten == -1)
+	{
+		return;
+	}
+   	else
+    {
+		sdmbn_raise_reprocess(cxt->gotten, cxt->cxid,
+				(struct pcap_pkthdr *)(pi->pheader),
+				(unsigned char *)(pi->packet));
+    }
+
+    return;
+}
+
+
+
+///// SDMBN Local Perflow State Handlers /////////////////////////////////////
+int local_get_perflow(PerflowKey *key, int id, int raiseEvents)
+{
+    if (NULL == key)
+    { return -1; }
+
+    int count = 0;
+    int h = 0;
+    for (h = 0; h < BUCKET_SIZE; h++)
+    {
+        pthread_mutex_lock(&ConnEntryLock);
+        connection *curr = bucket[h];
+        while (curr != NULL)
+        {
+            // Check dl_type
+            if (!(key->wildcards & WILDCARD_DL_TYPE) &&
+                    ntohs(curr->hw_proto) != key->dl_type)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_proto
+            if (!(key->wildcards & WILDCARD_NW_PROTO) &&
+                    curr->proto != key->nw_proto)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check tp_src
+            if (!(key->wildcards & WILDCARD_TP_SRC) &&
+                !(curr->s_port == key->tp_src ||
+                    (key->tp_flip && curr->d_port == key->tp_src)))
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check tp_dst
+            if (!(key->wildcards & WILDCARD_TP_DST) &&
+                !(curr->d_port == key->tp_dst ||
+                    (key->tp_flip && curr->s_port == key->tp_dst)))
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            int nw_src_mask = 0xFFFFFFFF;
+            if (!(key->wildcards & WILDCARD_NW_SRC_MASK))
+            { nw_src_mask = nw_src_mask << (32 - key->nw_src_mask); }
+
+            // Check nw_src
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_SRC) &&
+                    (nw_src_mask & curr->s_ip.s6_addr32[0]) != key->nw_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            int nw_dst_mask = 0xFFFFFFFF;
+            if (!(key->wildcards & WILDCARD_NW_DST_MASK))
+            { nw_dst_mask = nw_dst_mask << (32 - key->nw_dst_mask); }
+
+            // Check nw_dst
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_DST) &&
+                    (nw_dst_mask & curr->d_ip.s6_addr32[0]) != key->nw_dst)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Mark connection as returned with this get call 
+            if (raiseEvents)
+            	curr->gotten = id;
+            else
+            	curr->gotten = -1;
+
+      
+            // Prepare to send perflow state
+            int hashkey = curr->cxid;
+                     
+            // Serialize conn and asset structure into a single character 
+            // stream.
+			struct timeval start_serialize, end_serialize;
+   			gettimeofday(&start_serialize, NULL);
+            
+			char *state = (char *)serialize_conn_asset(curr, id); 
+   			
+			gettimeofday(&end_serialize, NULL);
+			long sec = end_serialize.tv_sec - start_serialize.tv_sec;
+			long usec = end_serialize.tv_usec - start_serialize.tv_usec;
+			long total = (sec * 1000 * 1000) + usec;
+			overall_pserz_time += total;
+			overall_pstate_size	+= strlen(state);
+			printf("STATS: PERFLOW STATE SIZE CURRENT = %zu\n", strlen(state));
+			printf("STATS: PERFLOW STATE SIZE OVERALL = %zu\n", overall_pstate_size);
+			printf("STATS: PERFLOW: TIME TO SERIALIZE CURRENT = %ldus\n", total);
+			printf("STATS: PERFLOW: TIME TO SERIALIZE OVERALL = %ldus\n", overall_pserz_time);
+            SERIALIZE_PRINT("serializing connection struct with multi flow %s",state);
+ 
+            if (NULL == state)
+            { continue; }
+
+            // Construct key
+            PerflowKey connkey;
+            if (AF_INET == curr->af)
+            {
+                connkey.nw_src = curr->s_ip.s6_addr32[0];
+                connkey.nw_src_mask = 32;
+                connkey.nw_dst = curr->d_ip.s6_addr32[0];
+                connkey.nw_dst_mask = 32;
+            }
+            else
+            { /* FIXME: Handle IPv6 */ }
+            connkey.tp_src = curr->s_port;
+            connkey.tp_dst = curr->d_port;
+            connkey.dl_type = curr->hw_proto;
+            connkey.nw_proto = curr->proto;
+            connkey.wildcards = WILDCARD_NONE;
+
+            // Send perflow state
+            int result = sdmbn_send_perflow(id, &connkey, state, hashkey, 
+                    count);
+            if (result < 0)
+            { }
+
+            // Increment count
+            count++;
+
+            // Clean-up
+            free(state);
+
+            // Move on to next connection
+            curr = curr->next;
+        }
+        pthread_mutex_unlock(&ConnEntryLock);
+    }
+
+    return count;
+}
+
+int local_put_perflow(int hashkey, PerflowKey *key, char *state)
+{
+    if (NULL == key || NULL == state)
+    { return -1; }
+
+    connection *cxt = NULL;
+    SERIALIZE_PRINT("deserializing connection struct with multi flow state \n%s", state);
+
+	struct timeval start_deserialize, end_deserialize;
+   	gettimeofday(&start_deserialize, NULL);
+   			
+    cxt = ser_parse(head_tra, "connection", state, NULL);
+	
+	gettimeofday(&end_deserialize, NULL);
+	long sec = end_deserialize.tv_sec - start_deserialize.tv_sec;
+	long usec = end_deserialize.tv_usec - start_deserialize.tv_usec;
+	long total = (sec * 1000 * 1000) + usec;
+	overall_pdeserz_time += total;
+	printf("STATS: PERFLOW: TIME TO DESERIALIZE CURRENT = %ldus\n", total);
+	printf("STATS: PERFLOW: TIME TO DESERIALIZE OVERALL = %ldus\n", overall_pdeserz_time);
+
+
+    
+    // Clear any mark of connection being gotten
+    cxt->gotten = 0;
+
+    struct in6_addr ips;
+    struct in6_addr ipd;
+
+    int af = AF_INET; //TODO Add support for IPv6
+    connection *head = NULL;
+    uint32_t hash;
+
+    if (AF_INET == af)
+    {
+        // ugly hack :(
+        // the way we do ip4/6 is DIRTY
+        ips.s6_addr32[0] = key->nw_src;
+        ipd.s6_addr32[0] = key->nw_dst;
+    }
+    else
+    { return -1; }
+
+    // find the right connection bucket
+    if (af == AF_INET)
+    {
+        hash = CXT_HASH4(IP4ADDR(&ips), IP4ADDR(&ipd), key->tp_src,
+                key->tp_dst, key->nw_proto);
+    }
+    /*else if (af == AF_INET6) 
+    { hash = CXT_HASH6(ip_src,ip_dst,src_port,dst_port,pi->proto); }*/
+    else
+    { return -1; }
+
+    pthread_mutex_lock(&ConnEntryLock);
+    head = bucket[hash];
+
+    // allocating a new connection ID
+    // TODO add locks
+    cxtrackerid++;
+    cxt->cxid = cxtrackerid;
+
+    // Add to linked list
+    cxt->prev = NULL;
+    if (head != NULL)
+    {
+        head->prev = cxt;
+        cxt->next = head;
+    }
+    else
+    { cxt->next = NULL; }
+    bucket[hash] = cxt;
+    pthread_mutex_unlock(&ConnEntryLock);
+
+    // If asset structure is present push it into the asset list.
+    if (cxt->c_asset || cxt->s_asset)
+    {
+        SERIALIZE_PRINT("Asset structure is present. Putting it");
+        put_asset_per_sip(key->nw_src, cxt->c_asset, cxt);     
+        put_asset_per_sip(key->nw_dst, cxt->s_asset, cxt);
+        cxt->c_asset = NULL; 
+        cxt->s_asset = NULL; // Let this get updated in the lookup
+                             // so that ref is incremented properly. 
+    }
+    return 1;
+}
+
+int local_del_perflow(PerflowKey *key, int id)
+{
+    INFO_PRINT("Deleting Perflow State");
+    if (NULL == key)
+    { return -1; }
+
+    int count = 0;
+    int h = 0;
+    for (h = 0; h < BUCKET_SIZE; h++)
+    {
+        pthread_mutex_lock(&ConnEntryLock);
+        connection *curr = bucket[h];
+        while (curr != NULL)
+        {
+            // Check dl_type
+            if (!(key->wildcards & WILDCARD_DL_TYPE) &&
+                    ntohs(curr->hw_proto) != key->dl_type)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_proto
+            if (!(key->wildcards & WILDCARD_NW_PROTO) &&
+                    curr->proto != key->nw_proto)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check tp_src
+            if (!(key->wildcards & WILDCARD_TP_SRC) &&
+                    curr->s_port != key->tp_src && curr->d_port != key->tp_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_src
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_SRC) &&
+                    curr->s_ip.s6_addr32[0] != key->nw_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_dst
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_DST) &&
+                    curr->d_ip.s6_addr32[0] != key->nw_dst)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Mark connection as returned with this get call
+            curr->gotten = id;
+
+            int hashkey = curr->cxid;
+            char *state = NULL;
+            
+
+            // Increment count
+            count++;
+
+
+            // TODO: Delete state the right way
+            // HACK: DELETE THE CONNECTION WE SENT
+            if (curr->prev)
+            { curr->prev->next = curr->next; }
+            else
+            { bucket[h]=curr->next; }
+
+            if (curr->next)
+            { curr->next->prev = curr->prev; }
+
+            connection *delete = curr;
+            
+            // Move on to next connection
+            curr = curr->next;
+            
+            // TODO: Delete state the right way
+            // HACK: DELETE THE CONNECTION WE SENT
+            del_connection(delete, &bucket[h]);
+        }
+        pthread_mutex_unlock(&ConnEntryLock);
+    }
+
+    return count;
+}
+
+int local_del_multiflow(PerflowKey *key, int id, int force)
+{
+    // If key is NULL attempt to delete all multiflows
+    //INFO_PRINT("Deleting Multi Flow States");
+    if (NULL == key)
+    { return del_all_multiflows(); }
+
+    // Key is present
+    // Search for the assetd pertaining to the key
+    int count = 0;
+    int h = 0;
+    for (h = 0; h < BUCKET_SIZE; h++)
+    {
+        pthread_mutex_lock(&ConnEntryLock);
+        connection *curr = bucket[h];
+        while (curr != NULL)
+        {
+            // Check dl_type
+            if (!(key->wildcards & WILDCARD_DL_TYPE) &&
+                    ntohs(curr->hw_proto) != key->dl_type)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_proto
+            if (!(key->wildcards & WILDCARD_NW_PROTO) &&
+                    curr->proto != key->nw_proto)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check tp_src
+            if (!(key->wildcards & WILDCARD_TP_SRC) &&
+                    curr->s_port != key->tp_src && curr->d_port!=key->tp_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_src
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_SRC) &&
+                    curr->s_ip.s6_addr32[0] != key->nw_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_dst
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_DST) &&
+                    curr->d_ip.s6_addr32[0] != key->nw_dst)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Mark connection as returned with this get call 
+            curr->gotten = id;
+
+            int hashkey = curr->cxid;
+            char *state = NULL;
+
+            // Del asset and Increment count
+            count += find_del_asset(curr->c_asset);
+            count += find_del_asset(curr->s_asset);
+
+            // Move on to next connection
+            curr = curr->next;
+
+        }
+        pthread_mutex_unlock(&ConnEntryLock);
+    }
+
+    return count;
+}
diff -urN prads/src/cxt.c.orig prads-sdmbn/src/cxt.c.orig
--- prads/src/cxt.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/src/cxt.c.orig	2014-02-17 17:20:12.000000003 -0600
@@ -0,0 +1,751 @@
+#include <assert.h>
+#include "common.h"
+#include "prads.h"
+#include "cxt.h"
+#include "sys_func.h"
+#include "config.h"
+#include "output-plugins/log.h"
+#include <SDMBN.h>
+#include "SDMBNLocal.h"
+#include "serialize.h"
+
+static void local_raise_reprocess(connection *cxt, packetinfo *pi);
+
+extern globalconfig config;
+
+uint64_t cxtrackerid;
+connection *bucket[BUCKET_SIZE];
+
+void cxt_init()
+{
+    cxtrackerid = 0;
+}
+
+/* freshly smelling connection :d */
+connection *cxt_new(packetinfo *pi)
+{
+    struct in6_addr ips;
+    struct in6_addr ipd;
+    connection *cxt;
+    cxtrackerid++;
+    cxt = (connection *) calloc(1, sizeof(connection));
+    assert(cxt);
+    cxt->cxid = cxtrackerid;
+
+    sdmbn_notify_flow_created();
+
+    cxt->af = pi->af;
+    if(pi->tcph) cxt->s_tcpFlags = pi->tcph->t_flags;
+    //cxt->s_tcpFlags |= (pi->tcph ? pi->tcph->t_flags : 0x00);//why??
+    //cxt->d_tcpFlags = 0x00;
+    cxt->s_total_bytes = pi->packet_bytes;
+    cxt->s_total_pkts = 1;
+    cxt->start_time = pi->pheader->ts.tv_sec;
+    cxt->last_pkt_time = pi->pheader->ts.tv_sec;
+
+    if(pi-> af== AF_INET6){
+        cxt->s_ip = PI_IP6SRC(pi);
+        cxt->d_ip = PI_IP6DST(pi);
+    }else {
+        ips.s6_addr32[0] = pi->ip4->ip_src;
+        ipd.s6_addr32[0] = pi->ip4->ip_dst;
+        cxt->s_ip = ips;
+        cxt->d_ip = ipd;
+    }
+
+    cxt->s_port = pi->s_port;
+    cxt->d_port = pi->d_port;
+    cxt->proto = pi->proto;
+    cxt->hw_proto = ntohs(pi->eth_type);
+
+    cxt->check = 0x00;
+    cxt->c_asset = NULL;
+    cxt->s_asset = NULL;
+    cxt->reversed = 0;
+
+    return cxt;
+}
+
+int connection_tracking(packetinfo *pi)
+{
+    static char ip_addr_s[INET6_ADDRSTRLEN];
+    static char ip_addr_d[INET6_ADDRSTRLEN];
+    cx_track(pi);
+
+    if(config.cflags & CONFIG_CONNECT){
+        log_connection(pi->cxt, CX_EXCESSIVE);
+    }
+    return 0;
+}
+
+int cxt_update_client(connection *cxt, packetinfo *pi)
+{
+    cxt->last_pkt_time = pi->pheader->ts.tv_sec;
+
+    if(pi->tcph) cxt->s_tcpFlags |= pi->tcph->t_flags;
+    cxt->s_total_bytes += pi->packet_bytes;
+    cxt->s_total_pkts += 1;
+
+    pi->cxt = cxt;
+    pi->sc = SC_CLIENT;
+    if(!cxt->c_asset)
+        cxt->c_asset = pi->asset; // connection client asset
+    if (cxt->s_total_bytes > MAX_BYTE_CHECK
+        || cxt->s_total_pkts > MAX_PKT_CHECK) {
+        return 0;   // Dont Check!
+    }
+    return SC_CLIENT;
+}
+
+int cxt_update_server(connection *cxt, packetinfo *pi)
+{
+    cxt->last_pkt_time = pi->pheader->ts.tv_sec;
+
+    if(pi->tcph) cxt->d_tcpFlags |= pi->tcph->t_flags;
+    cxt->d_total_bytes += pi->packet_bytes;
+    cxt->d_total_pkts += 1;
+
+    pi->cxt = cxt;
+    pi->sc = SC_SERVER;
+    if(!cxt->s_asset)
+        cxt->s_asset = pi->asset; // server asset
+    if (cxt->d_total_bytes > MAX_BYTE_CHECK
+        || cxt->d_total_pkts > MAX_PKT_CHECK) {
+        return 0;   // Dont check!
+    }
+    return SC_SERVER;
+
+}
+
+/* return value: client or server?
+ *** USED TO BE: 0 = dont check, 1 = client, 2 = server
+ * now returns 0, SC_CLIENT(=1), SC_SERVER(=2)
+ */
+
+int cx_track(packetinfo *pi) {
+    struct in6_addr *ip_src;
+    struct in6_addr *ip_dst;
+    struct in6_addr ips;
+    struct in6_addr ipd;
+    uint16_t src_port = pi->s_port;
+    uint16_t dst_port = pi->d_port;
+    int af = pi->af;
+    connection *cxt = NULL;
+    connection *head = NULL;
+    uint32_t hash;
+
+
+    if(af== AF_INET6){
+        ip_src = &PI_IP6SRC(pi);
+        ip_dst = &PI_IP6DST(pi);
+    }else {
+        // ugly hack :(
+        // the way we do ip4/6 is DIRTY
+        ips.s6_addr32[0] = pi->ip4->ip_src;
+        ipd.s6_addr32[0] = pi->ip4->ip_dst;
+        ip_src = &ips;
+        ip_dst = &ipd;
+    }
+
+    // find the right connection bucket
+    if (af == AF_INET) {
+        hash = CXT_HASH4(IP4ADDR(ip_src),IP4ADDR(ip_dst),src_port,dst_port,pi->proto);
+    } else if (af == AF_INET6) {
+        hash = CXT_HASH6(ip_src,ip_dst,src_port,dst_port,pi->proto);
+    }
+    cxt = bucket[hash];
+    head = cxt;
+
+    // search through the bucket
+    while (cxt != NULL) {
+        // Two-way compare of given connection against connection table
+        if (af == AF_INET) {
+            if (CMP_CXT4(cxt,IP4ADDR(ip_src),src_port,IP4ADDR(ip_dst),dst_port)){
+                // Client sends first packet (TCP/SYN - UDP?) hence this is a client
+                local_raise_reprocess(cxt, pi);
+                return cxt_update_client(cxt, pi);
+            } else if (CMP_CXT4(cxt,IP4ADDR(ip_dst),dst_port,IP4ADDR(ip_src),src_port)) {
+                // This is a server (Maybe not when we start up but in the long run)
+                local_raise_reprocess(cxt, pi);
+                return cxt_update_server(cxt, pi);
+            }
+        } else if (af == AF_INET6) {
+            if (CMP_CXT6(cxt,ip_src,src_port,ip_dst,dst_port)){
+                return cxt_update_client(cxt, pi);
+            } else if (CMP_CXT6(cxt,ip_dst,dst_port,ip_src,src_port)){
+                return cxt_update_server(cxt, pi);
+            }
+        }
+        cxt = cxt->next;
+    }
+    // bucket turned upside down didn't yeild anything. new connection
+    cxt = cxt_new(pi);
+    log_connection(cxt, CX_NEW);
+
+    /* * New connections are pushed on to the head of bucket[s_hash] */
+    cxt->next = head;
+    if (head != NULL) {
+        // are we doubly linked?
+        head->prev = cxt;
+    }
+    bucket[hash] = cxt;
+    pi->cxt = cxt;
+
+    /* * Return value should be 1, telling to do client service fingerprinting */
+    return 1;
+}
+
+void reverse_pi_cxt(packetinfo *pi)
+{
+    uint8_t tmpFlags;
+    uint64_t tmp_pkts;
+    uint64_t tmp_bytes;
+    struct in6_addr tmp_ip;
+    uint16_t tmp_port;
+    connection *cxt;
+
+    cxt = pi->cxt;
+
+    /* First we chang the cxt */
+    /* cp src to tmp */
+    tmpFlags = cxt->s_tcpFlags;
+    tmp_pkts = cxt->s_total_pkts;
+    tmp_bytes = cxt->s_total_bytes;
+    tmp_ip = cxt->s_ip;
+    tmp_port = cxt->s_port;
+
+    /* cp dst to src */
+    cxt->s_tcpFlags = cxt->d_tcpFlags;
+    cxt->s_total_pkts = cxt->d_total_pkts;
+    cxt->s_total_bytes = cxt->d_total_bytes;
+    cxt->s_ip = cxt->d_ip;
+    cxt->s_port = cxt->d_port;
+
+    /* cp tmp to dst */
+    cxt->d_tcpFlags = tmpFlags; 
+    cxt->d_total_pkts = tmp_pkts;
+    cxt->d_total_bytes = tmp_bytes;
+    cxt->d_ip = tmp_ip;
+    cxt->d_port = tmp_port;
+
+    /* Not taking any chances :P */
+    cxt->c_asset = cxt->s_asset = NULL;
+    cxt->check = 0x00;
+
+    /* Then we change pi */
+    if (pi->sc == SC_CLIENT)
+       pi->sc = SC_SERVER;
+    else
+       pi->sc = SC_CLIENT;
+}
+
+/*
+ This sub marks sessions as ENDED on different criterias:
+
+ XXX: May be the fugliest code in PRADS :-(
+*/
+
+void end_sessions()
+{
+
+    connection *cxt;
+    int iter;
+    int cxstatus = CX_NONE;
+    int ended, expired = 0;
+    uint32_t curcxt = 0;
+    time_t check_time = time(NULL);
+
+    log_rotate(check_time);
+    for (iter = 0; iter < BUCKET_SIZE; iter++) {
+        cxt = bucket[iter];
+        while (cxt != NULL) {
+            curcxt++;
+            /* TCP */
+            if (cxt->proto == IP_PROTO_TCP) {
+                /* * FIN from both sides */
+                if (cxt->s_tcpFlags & TF_FIN && cxt->d_tcpFlags & TF_FIN
+                    && (check_time - cxt->last_pkt_time) > 5) {
+                    cxstatus = CX_ENDED;
+                } /* * RST from either side */
+                else if ((cxt->s_tcpFlags & TF_RST
+                          || cxt->d_tcpFlags & TF_RST)
+                          && (check_time - cxt->last_pkt_time) > 5) {
+                    cxstatus = CX_ENDED;
+                }
+                else if ((check_time - cxt->last_pkt_time) > TCP_TIMEOUT) {
+                    cxstatus = CX_EXPIRE;
+                }
+            }
+            /* UDP */
+            else if (cxt->proto == IP_PROTO_UDP
+                     && (check_time - cxt->last_pkt_time) > 60) {
+                cxstatus = CX_EXPIRE;
+            }
+            /* ICMP */
+            else if (cxt->proto == IP_PROTO_ICMP
+                     || cxt->proto == IP6_PROTO_ICMP) {
+                if ((check_time - cxt->last_pkt_time) > 60) {
+                    cxstatus = CX_EXPIRE;
+                }
+            }
+            /* All Other protocols */
+            else if ((check_time - cxt->last_pkt_time) > TCP_TIMEOUT) {
+                cxstatus = CX_EXPIRE;
+            }
+
+            if (cxstatus == CX_ENDED || cxstatus == CX_EXPIRE) {
+                /* remove from the hash */
+                if (cxt->prev)
+                    cxt->prev->next = cxt->next;
+                if (cxt->next)
+                    cxt->next->prev = cxt->prev;
+                connection *tmp = cxt;
+
+                log_connection(cxt, cxstatus);
+                cxstatus = CX_NONE;
+
+                cxt = cxt->prev;
+
+                del_connection(tmp, &bucket[iter]);
+                if (cxt == NULL) {
+                    bucket[iter] = NULL;
+                }
+            } else {
+                cxt = cxt->prev;
+            }
+        } // end while cxt
+    } // end for buckets
+}
+
+void log_connection_all()
+{
+    int i;
+    connection *cxt;
+    if(! (config.cflags & CONFIG_CXWRITE))
+        return;
+    for(i = 0; i < BUCKET_SIZE; i++) {
+        cxt = bucket[i];
+        while(cxt) {
+            log_connection(cxt, CX_HUMAN);
+            cxt = cxt->next;
+        }
+    }
+}
+
+void del_connection(connection * cxt, connection ** bucket_ptr)
+{
+    connection *prev = cxt->prev;       /* OLDER connections */
+    connection *next = cxt->next;       /* NEWER connections */
+
+    if (prev == NULL) {
+        // beginning of list
+        *bucket_ptr = next;
+        // not only entry
+        if (next)
+            next->prev = NULL;
+    } else if (next == NULL) {
+        // at end of list!
+        prev->next = NULL;
+    } else {
+        // a node.
+        prev->next = next;
+        next->prev = prev;
+    }
+
+    /*
+     * Free and set to NULL 
+     */
+    free(cxt);
+    cxt = NULL;
+
+    sdmbn_notify_flow_destroyed();
+}
+
+void end_all_sessions()
+{
+    connection *cxt;
+    int cxkey;
+    FILE *cxtFile = NULL;
+
+    log_rotate(time(NULL));
+    for (cxkey = 0; cxkey < BUCKET_SIZE; cxkey++) {
+        cxt = bucket[cxkey];
+        while (cxt != NULL) {
+            connection *tmp = cxt;
+
+            log_connection(cxt, CX_ENDED);
+            cxt = cxt->next;
+            del_connection(tmp, &bucket[cxkey]);
+            if (cxt == NULL) {
+                bucket[cxkey] = NULL;
+            }
+        }
+    }
+    if (cxtFile != NULL) {
+        fclose(cxtFile);
+    }
+}
+
+void cxt_log_buckets(int dummy)
+{
+    connection *cxt = NULL;
+    FILE *logfile = NULL;
+    int i;
+    int len;
+
+    logfile = fopen("/tmp/prads-buckets.log", "w");
+    if (!logfile)
+        return;
+
+    dlog("Recieved SIGUSR1 - Dumping bucketlist to logfile\n");
+    for (i = 0; i < BUCKET_SIZE; i++) {
+        len = 0;
+        for (cxt = bucket[i]; cxt; cxt = cxt->next)
+            len++;
+        if (len > 0)
+            fprintf(logfile, "%d in bucket[%5d]\n", len, i);
+    }
+
+    fflush(logfile);
+    fclose(logfile);
+}
+
+
+
+/* vector comparisons to speed up cx tracking.
+ * meaning, compare source:port and dest:port at the same time.
+ *
+ * about vectors and potential improvements:
+ * * all 64bit machines have at least SSE2 instructions * *BUT* there is no guarantee we won't loose time on
+ * copying the vectors around.
+ * ... indeed, a quick objdump shows us that
+ * there is a shitton of mov instructions to align the addresses.
+ *
+ * Needs support to give improvements: 
+ * the addresses should already be aligned as a 128-bit word
+ * in the connection tracking bucket.
+ *
+ * note, we can employ the same technique for ipv6 addresses, but
+ * one address at a time.
+ */
+#ifdef VECTOR_CXTRACKER
+// vector fill: srcprt,dstprt,srcip,dstip = 96 bytes. rest is 0
+#define VEC_FILL(vec, _ipsrc,_ipdst,_portsrc,_portdst) do {\
+    vec.s[0] = (_portsrc); \
+    vec.s[1] = (_portdst); \
+    vec.w[1] = (_ipsrc); \
+    vec.w[2] = (_ipdst); \
+    vec.w[3] = 0; \
+} while (0)
+
+inline void cx_track_simd_ipv4(packetinfo *pi)
+{
+    connection *cxt = NULL;
+    connection *head = NULL;
+    uint32_t hash;
+
+    // add to packetinfo ? dont through int32 around :)
+    hash = make_hash(pi);
+    cxt = bucket[hash];
+    head = cxt;
+
+    ip6v incoming;
+    ip6v compare;
+    VEC_FILL(incoming,
+        pi->ip_src.__u6_addr.__u6_addr32[0],
+        pi->ip_dst.__u6_addr.__u6_addr32[0],
+        pi->s_port,
+        pi->d_port);
+    while (cxt != NULL) {
+        VEC_FILL(compare,
+        cxt->s_ip.__u6_addr.__u6_addr32[0],
+        cxt->d_ip.__u6_addr.__u6_addr32[0],
+        cxt->s_port,
+        cxt->d_port);
+
+        // single-instruction compare -msse2
+        compare.v = __builtin_ia32_pcmpeqd128(incoming.v,compare.v);
+        // same thing, really. c == v iff c ^ v == 0
+        //compare.v = compare.v ^ incoming.v;
+
+        // 64-bit compare reduce
+        if(!(compare.i[0] & compare.i[1])){
+            //ok
+            dlog("[*] Updating src connection: %lu\n",cxt->cxid);
+            cxt_update_src(cxt,pi);
+            return;
+        }
+
+        // compare the other direction
+        VEC_FILL(compare,
+        cxt->d_ip.__u6_addr.__u6_addr32[0],
+        cxt->s_ip.__u6_addr.__u6_addr32[0],
+        cxt->d_port,
+        cxt->s_port);
+
+        compare.v = __builtin_ia32_pcmpeqd128(incoming.v,compare.v);
+        if(!(compare.i[0] & compare.i[1])){
+            dlog("[*] Updating dst connection: %lu\n",cxt->cxid);
+            cxt_update_dst(cxt,pi);
+            return;
+        }
+        cxt = cxt->next;
+    }
+    if (cxt == NULL) {
+        cxt = (connection *) connection_alloc();
+        //cxt = (connection *) calloc(1, sizeof(connection));
+        if (head != NULL) {
+            head->prev = cxt;
+        }
+        cxt = cxt_new(pi);
+        dlog("[*] New connection: %lu\n",cxt->cxid);
+        cxt->next = head;
+        bucket[hash] = cxt;
+        return;
+    }
+    printf("[*] Error in session tracking...\n");
+    exit (1);
+}
+
+#endif
+
+///// SDMBN Local Event Raisers //////////////////////////////////////////////
+static void local_raise_reprocess(connection *cxt, packetinfo *pi)
+{
+    if (!(cxt->gotten))
+    { return; }
+
+    sdmbn_raise_reprocess(cxt->gotten, cxt->cxid, 
+            (struct pcap_pkthdr *)(pi->pheader), 
+            (unsigned char *)(pi->packet));
+    return;
+}
+
+
+
+///// SDMBN Local Perflow State Handlers /////////////////////////////////////
+int local_get_perflow(PerflowKey *key, int id)
+{
+    if (NULL == key)
+    { return -1; }
+
+    int count = 0;
+    int h = 0;
+    for (h = 0; h < BUCKET_SIZE; h++)
+    {
+        connection *curr = bucket[h];
+        while (curr != NULL)
+        {
+            // Check dl_type
+            if (!(key->wildcards & WILDCARD_DL_TYPE) &&
+                    ntohs(curr->hw_proto) != key->dl_type)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_proto
+            if (!(key->wildcards & WILDCARD_NW_PROTO) &&
+                    curr->proto != key->nw_proto)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check tp_src
+            if (!(key->wildcards & WILDCARD_TP_SRC) &&
+                    curr->s_port != key->tp_src && curr->d_port != key->tp_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_src
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_SRC) &&
+                    curr->s_ip.s6_addr32[0] != key->nw_src)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Check nw_dst
+            // ugly hack :(
+            // the way we do ip4/6 is DIRTY
+            if (!(key->wildcards & WILDCARD_NW_DST) &&
+                    curr->d_ip.s6_addr32[0] != key->nw_dst)
+            {
+                curr = curr->next;
+                continue;
+            }
+
+            // Mark connection as returned with this get call 
+            curr->gotten = id;
+
+            // Prepare to send perflow state
+            curr->c_asset = curr->s_asset = NULL; // TMPHACK
+            int hashkey = curr->cxid;
+            char *state = NULL;
+            
+	    // If multi-flow state get is enabled
+            if (TRANSFER_MULTI_FLOW == 1)
+            {
+<<<<<<< HEAD
+                asset* a = NULL;
+                a = (asset*)get_asset_per_sip(curr->s_ip.s6_addr32[0], curr, &state);
+=======
+                pthread_rwlock_wrlock(&rwlock);
+                asset* a = get_asset_per_sip(curr->s_ip.s6_addr32[0], curr, 
+                        &state);
+>>>>>>> 3f1c9ca85a89f203ed049b0e2d680542ad09c268
+                //if(a != NULL) state = ser_ialize(head_tra,"asset", a, NULL, 0);
+                              
+		// curr->c_asset = a;
+                //state = ser_ialize(head_tra, "connection", curr, NULL, 0);
+                #ifdef SER_DEBUG
+		    printf("serializing connection struct with multi flow %s\n",state);
+		#endif
+                curr->c_asset = curr->s_asset = NULL;
+            }
+	    else
+            {
+                state = sdmbn_base64_encode(curr, sizeof(*curr));
+                #ifdef SER_DEBUG
+                    printf("serializing connection struct without multi flow \n%s \n", state);
+		#endif
+            }
+
+            if (NULL == state)
+            { continue; }
+
+            // Construct key
+            PerflowKey connkey;
+            if (AF_INET == curr->af)
+            {
+                connkey.nw_src = curr->s_ip.s6_addr32[0];
+                connkey.nw_dst = curr->d_ip.s6_addr32[0];
+            }
+            else
+            { /* FIXME: Handle IPv6 */ }
+            connkey.tp_src = curr->s_port;
+            connkey.tp_dst = curr->d_port;
+            connkey.dl_type = curr->hw_proto;
+            connkey.nw_proto = curr->proto;
+            connkey.wildcards = WILDCARD_NONE;
+
+            // Send perflow state
+            int result = sdmbn_send_perflow(id, &connkey, state, hashkey, 
+                    count);
+            if (result < 0)
+            { }
+
+            // Increment count
+            count++;
+
+            // Clean-up
+            free(state);
+
+            /* TODO: Delete state the right way
+            // HACK: DELETE THE CONNECTION WE SENT
+            if (curr->prev)
+                curr->prev->next = curr->next;
+            if (curr->next)
+                curr->next->prev = curr->prev;
+
+            connection *delete = curr;
+            */
+
+            // Move on to next connection
+            curr = curr->next;
+
+            /* TODO: Delete state the right way
+            // HACK: DELETE THE CONNECTION WE SENT
+            del_connection(delete, &bucket[h]);
+            */
+        }
+    }
+
+    return count;
+}
+
+int local_put_perflow(int hashkey, PerflowKey *key, char *state)
+{
+    if (NULL == key || NULL == state)
+    { return -1; }
+
+    connection *cxt = NULL;
+    if (TRANSFER_MULTI_FLOW == 1)
+    {
+        #ifdef SER_DEBUG
+            printf("deserializing connection struct with multi flow state \n%s \n", state);
+	#endif
+        cxt = ser_parse(head_tra, "connection", state, NULL);
+    }
+    else
+    {
+        #ifdef SER_DEBUG
+            printf("deserializing connection struct without multi flow state \n%s \n", state);
+	#endif 
+       cxt = (connection *)sdmbn_base64_decode(state);
+    }
+    // Clear any mark of connection being gotten
+    cxt->gotten = 0;
+
+    struct in6_addr ips;
+    struct in6_addr ipd;
+
+    int af = AF_INET; //TODO Add support for IPv6
+    connection *head = NULL;
+    uint32_t hash;
+
+    if (AF_INET == af)
+    {
+        // ugly hack :(
+        // the way we do ip4/6 is DIRTY
+        ips.s6_addr32[0] = key->nw_src;
+        ipd.s6_addr32[0] = key->nw_dst;
+    }
+    else
+    { return -1; }
+
+    // find the right connection bucket
+    if (af == AF_INET)
+    {
+        hash = CXT_HASH4(IP4ADDR(&ips), IP4ADDR(&ipd), key->tp_src,
+                key->tp_dst, key->nw_proto);
+    }
+    //   else if (af == AF_INET6) 
+    //   { hash = CXT_HASH6(ip_src,ip_dst,src_port,dst_port,pi->proto); }
+    else
+    { return -1; }
+
+    head = bucket[hash];
+
+    // allocating a new connection ID
+    // TODO add locks
+    cxtrackerid++;
+    cxt->cxid = cxtrackerid;
+
+    // Add to linked list
+    cxt->prev = NULL;
+    if (head != NULL)
+    {
+        head->prev = cxt;
+        cxt->next = head;
+    }
+    else
+    { cxt->next = NULL; }
+    bucket[hash] = cxt;
+    
+    // If asset structure is present push it into the asset list.
+    if (cxt->c_asset)
+    {
+        #ifdef SER_DEBUG
+            printf("Asset structure is present. Putting it");
+        #endif
+	put_asset_per_sip(put_asset_per_sip, cxt->c_asset, cxt);     
+    }
+    
+    return 1;
+}
diff -urN prads/src/Makefile prads-sdmbn/src/Makefile
--- prads/src/Makefile	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/Makefile	2014-02-17 17:20:12.000000003 -0600
@@ -1,12 +1,12 @@
 #Makefile
 #CC=gcc
 UNAME := $(shell uname -s)
-CFLAGS=-O3
+CFLAGS+=-O3
 
 #STATIC=y
 ifeq (${STATIC},)
-LDFLAGS+=-lpcap -lpcre -lresolv
-CFLAGS+=-DCONFDIR='"${CONFDIR}/"' -DRELEASE='"$(shell git describe | cut -f2- -d_ | sed s/`git tag -l | grep -v /| tail -n1`//)"'
+LDFLAGS+=-lpcap -lpcre -lresolv -lsdmbn -ljson-c -lpthread
+CFLAGS+=-DCONFDIR='"${CONFDIR}/"' -DRELEASE=''
 else
 
 CFLAGS+=-DCONFDIR='"prads/"'
@@ -15,10 +15,10 @@
 endif
 
 ifneq (${DEBUG},)
-CFLAGS = -g -DDEBUG -Wall -DCONFDIR='"${CONFDIR}/"'
+CFLAGS+= -g -DDEBUG -Wall
 endif
 ifneq (${PROFILE},)
-CFLAGS=-g -pg -DCONFDIR='"${CONFDIR}/"'
+CFLAGS+=-g -pg
 endif
 ifneq (${EXTRADEBUG},)
 CFLAGS+= -DDUMP_HASH -DDEBUG_HASH -DDEBUG=2 -DDEBUG=2
@@ -46,7 +46,7 @@
 LOG_OBJ = output-plugins/log_dispatch.o output-plugins/log_stdout.o output-plugins/log_file.o output-plugins/log_fifo.o output-plugins/log_ringbuffer.o output-plugins/log_sguil.o
 CXT_OBJ = cxt.o
 MODULES = dhcp.o dump_dns.o mac.o ${SERVICE_OBJ} ${IPFP_OBJ} ${CXT_OBJ} ${LOG_OBJ}
-OBJECTS = bstrlib.o sig_tcp.o config.o sys_func.o assets.o prads.o ${MODULES}
+OBJECTS = bstrlib.o sig_tcp.o config.o sys_func.o assets.o serialize.o prads.o ${MODULES}
 SHM_CLIENT_OBJECTS = shm-client.o
 
 all: prads shm-client
diff -urN prads/src/prads.c prads-sdmbn/src/prads.c
--- prads/src/prads.c	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/prads.c	2014-04-15 13:53:57.000000003 -0500
@@ -44,11 +44,17 @@
 //#include "output-plugins/log_init.h"
 #include "output-plugins/log.h"
 
+#include <SDMBN.h>
+#include "SDMBNLocal.h"
+#include <pcap/pcap.h>
+#include <sys/time.h>
+#include "serialize.h"
+#include "bstrlib.h"
 #ifndef CONFDIR
 #define CONFDIR "/etc/prads/"
 #endif
 
-#define ARGS "C:c:b:d:Dg:hi:p:r:u:va:l:L:f:qtxs:OXFRMSAKUTIZtHPB"
+#define ARGS "C:c:b:d:Dg:hi:p:r:u:va:l:L:f:qtxs:OXFRMSAKUTIZtHPBw:"
 
 /*  G L O B A L S  *** (or candidates for refactoring, as we say)***********/
 globalconfig config;
@@ -97,15 +103,44 @@
 void set_pkt_end_ptr (packetinfo *pi);
 inline int filter_packet(const int af, void *ip);
 
+//// SDMBN packet output code ////////////////////////////////////////////////
+static pcap_t *open_writeiface(char *writeiface)
+{
+    char errbuf[PCAP_ERRBUF_SIZE];
+    errbuf[0] = 0;
+    pcap_t *live = pcap_open_live(writeiface, 0, 1, 10, errbuf);
+    if (!live)
+    {
+        fprintf(stderr, "Failed to open network interface %s for writing packets after processing: %s\n", writeiface, errbuf);
+        return NULL;
+    }
+//    fprintf(stderr, "Opened network interface %s for writing packets after processing\n", writeiface);
+    return live;
+}
+
+static void close_writeiface(pcap_t *live)
+{
+    pcap_close(live);
+}
+
 /* F U N C T I O N S  ********************************************************/
 
 void got_packet(u_char * useless, const struct pcap_pkthdr *pheader,
                 const u_char * packet)
 {
+    // SDMBN pre-process packet
+    ProcessContext context;
+    sdmbn_preprocess_packet(pheader, packet, &context);
+    if (context.stop)
+    { return; }
+
+    struct timeval recv_time;
+    gettimeofday(&recv_time, NULL);
     config.pr_s.got_packets++;
     packetinfo pstruct = {0};
     packetinfo *pi = &pstruct;
-    pi->our = 1;
+    pi->drop_flag = false;
+	pi->our = 1;
     pi->packet = packet;
     pi->pheader = pheader;
     set_pkt_end_ptr (pi);
@@ -137,9 +172,38 @@
     if (!pi->our) vlog(0x3, "Not our network packet. Tracked, but not logged.\n");
 #endif
     inpacket = 0;
+
+    if (htons(80) == pi->s_port || htons(80) == pi->d_port)
+    { sdmbn_notify_packet_received("HTTP", &recv_time); }
+    else if (htons(443) == pi->s_port || htons(443) == pi->d_port)
+    { sdmbn_notify_packet_received("HTTPS", &recv_time); }
+    else
+    { sdmbn_notify_packet_received("UNKNOWN", &recv_time); }
+
+    // Write packet after processing, if requested
+    if (config.live && pi->drop_flag == false)
+    {
+        int bytes = pcap_sendpacket(config.live, packet, pheader->caplen);
+        if (bytes < 0)
+        { 
+            fprintf(stderr, "Failed to write packet of length %d to network interface after processing: ", pheader->caplen); 
+            pcap_perror(config.live, "");
+        }
+//        fprintf(stderr, "Wrote packet of length %d to network interface after processing\n", bytes);
+    }
+
+    // SDMBN post-process packet
+    sdmbn_postprocess_packet(pheader, packet, &context);
+
     return;
 }
 
+//// SDMBN local packet processing function //////////////////////////////////
+int local_process_packet(struct pcap_pkthdr *hdr, unsigned char *pkt)
+{
+    got_packet(NULL, hdr, pkt);
+}
+
 /* does this ip belong to our network? do we care about the packet?
  *
  * unfortunately pcap sends us packets in host order
@@ -422,10 +486,10 @@
                     }
                     gre_header_len += GRE_SRE_HDR_LEN;
 
-                    if (gsre != NULL && (ntohs(gsre->af) == 0) && (gsre->sre_length == 0))
+                    if (gsre != NULL && (ntohs(gsre->af) == 0) )//&& (gsre->sre_length == 0))
                         break;
 
-                    gre_header_len += gsre->sre_length;
+                    //gre_header_len += gsre->sre_length;
                     gsre = (gre_sre_header *)(pi->greh + gre_header_len);
                     if (gsre == NULL)
                         return;
@@ -1031,6 +1095,7 @@
         del_signature_lists();
         unload_tcp_sigs();
         end_logging();
+        free(head_tra);
         if(!ISSET_CONFIG_QUIET(config)){
            print_prads_stats();
            if(!config.pcap_file)
@@ -1156,6 +1221,7 @@
     olog(" -x              Conne[x]ion tracking output  - New, expired and ended.\n");
     olog(" -Z              Passive DNS (Experimental).\n");
     olog(" -H              DHCP fingerprinting (Expermiental).\n");
+    olog(" -w <iface>      Output packets to network device <iface> after processing\n");
     olog(" -h              This help message.\n");
 }
 
@@ -1458,10 +1524,180 @@
     pcap_freecode(&cfilter);
 
     cxt_init();
+
+    // Initialize SDMBN
+    SDMBNLocals locals;
+    bzero(&locals, sizeof(locals));
+    locals.get_perflow = &local_get_perflow;
+    locals.put_perflow = &local_put_perflow;
+    locals.get_multiflow = &local_get_multiflow;
+    locals.put_multiflow = &local_put_multiflow;
+    locals.delete_all_flows = &local_del_multiflow;
+    locals.delete_multiflow = &local_del_multiflow;
+    locals.delete_perflow = &local_del_perflow;
+    locals.process_packet = &local_process_packet;
+    locals.device = config.dev;
+    sdmbn_init(&locals);
+
+    // Connection Table Lock
+    pthread_mutex_init(&ConnEntryLock, NULL);
+    // Asset Table Lock
+    pthread_mutex_init(&AssetEntryLock, NULL);
+    
+    setup_serialize_translators();
+
+    // Open interface for writing packets after processing, if requested
+    if (config.writeiface)
+    { config.live = open_writeiface(config.writeiface); }
+
     olog("[*] Sniffing...\n");
     pcap_loop(config.handle, -1, got_packet, NULL);
 
+    // Close interface for writing packets after processing, if it was opened
+    if (config.live)
+    { close_writeiface(config.live); }
+
+    // Clean-up SDMBN
+    sdmbn_cleanup();
+
     game_over();
     return (0);
 }
 
+///// SDMBN Local Allflows State Handlers //////////////////////////////////////
+int local_get_allflows(int id)
+{
+    // FIXME: Lock allflows state
+
+    // Prepare to send allflows state    
+    char *state = sdmbn_base64_encode(&config.pr_s, sizeof(config.pr_s));
+    if (NULL == state)
+    { return -1; }
+    
+    // Flush the counters
+    memset(&config.pr_s, 0, sizeof(config.pr_s));
+
+    // FIXME: Unlock allflows state
+
+    // Send allflows state
+    int result = sdmbn_send_allflows(id, state, 0);
+
+    // Clean-up
+    free(state);
+
+    return 1;
+}
+
+int local_put_allflows(int hashkey, char *state)
+{
+    // Decode allflows state
+    prads_stat *received = sdmbn_base64_decode(state);
+    if (NULL == received)
+    { return -1; }
+
+    // FIXME: Lock allflows state
+   
+    memcpy(&config.pr_s, received, sizeof(config.pr_s));
+
+    // FIXME: Unlock allflows state
+    
+    // Clean-up
+    free(received);
+
+    return 1;
+}
+
+
+
+ser_tra_t* setup_serialize_translators()
+{
+ 
+    // printf("[Debug]: Setting up serializer translator/n");
+    ser_tra_t *tra1, *tra2, *tra3, *tra4;
+    ser_field_t * field;
+
+    // translator for connection
+    head_tra = ser_new_tra("connection",sizeof(connection),NULL);
+    ser_new_field(head_tra,"time_t",0,"start_time",offsetof(connection,start_time));
+    ser_new_field(head_tra,"time_t",0,"last_pkt_time",offsetof(connection,last_pkt_time));
+    ser_new_field(head_tra,"uint32_t",0,"cxid",offsetof(connection,cxid));
+    ser_new_field(head_tra,"uint8_t",0,"reversed",offsetof(connection,reversed));
+    ser_new_field(head_tra,"uint32_t",0,"af",offsetof(connection,af));
+    ser_new_field(head_tra,"uint16_t",0,"hw_proto",offsetof(connection,hw_proto));
+    ser_new_field(head_tra,"uint8_t",0,"proto",offsetof(connection,proto));
+    ser_new_field(head_tra,"in6",0,"s_ip",offsetof(connection,s_ip));
+    ser_new_field(head_tra,"in6",0,"d_ip",offsetof(connection,d_ip));
+    ser_new_field(head_tra,"uint16_t",0,"s_port",offsetof(connection,s_port));
+    ser_new_field(head_tra,"uint16_t",0,"d_port",offsetof(connection,d_port));
+    ser_new_field(head_tra,"uint32_t",0,"s_total_pkts",offsetof(connection,s_total_pkts));
+    ser_new_field(head_tra,"uint32_t",0,"s_total_bytes",offsetof(connection,s_total_bytes));
+    ser_new_field(head_tra,"uint32_t",0,"d_total_pkts",offsetof(connection,d_total_pkts));
+    ser_new_field(head_tra,"uint32_t",0,"d_total_bytes",offsetof(connection,d_total_bytes));
+    ser_new_field(head_tra,"uint8_t",0,"s_tcpFlags",offsetof(connection,s_tcpFlags));
+    ser_new_field(head_tra,"uint8_t",0,"__pad__",offsetof(connection,__pad__));
+    ser_new_field(head_tra,"uint8_t",0,"d_tcpFlags",offsetof(connection,d_tcpFlags));
+    ser_new_field(head_tra,"uint8_t",0,"check",offsetof(connection,check));
+    ser_new_field(head_tra,"asset",1,"c_asset",offsetof(connection,c_asset));
+    ser_new_field(head_tra,"asset",1,"s_asset",offsetof(connection,s_asset));
+    ser_new_field(head_tra,"uint32_t",0,"gotten",offsetof(connection,gotten));
+ 
+    // translator for asset
+    tra0 = ser_new_tra("asset",sizeof(asset),head_tra);
+    //ser_new_field(tra0,"asset",1,"prev",offsetof(asset,prev));
+    ser_new_field(tra0,"time_t",0,"first_seen",offsetof(asset,first_seen));
+    ser_new_field(tra0,"time_t",0,"last_seen",offsetof(asset,last_seen));
+    ser_new_field(tra0,"ushort",0,"i_attempts",offsetof(asset,i_attempts));
+    ser_new_field(tra0,"int",0,"af",offsetof(asset,af));
+    ser_new_field(tra0,"uint16_t",0,"vlan",offsetof(asset,vlan));
+    ser_new_field(tra0,"in6",0,"ip_addr",offsetof(asset,ip_addr));
+    ser_new_field(tra0,"serv_asset",1,"services",offsetof(asset,services));
+    ser_new_field(tra0,"os_asset",1,"os",offsetof(asset,os));
+    
+    // translator for bstring
+    tra1 = ser_new_tra("tagstr",sizeof(tagstr),tra0);
+    ser_new_field(tra1,"int",0,"mlen",offsetof(tagstr,mlen));
+    ser_new_field(tra1,"int",0,"slen",offsetof(tagstr,slen));
+    ser_new_field(tra1,"string",0,"data",offsetof(tagstr,data));
+    
+    // translator for serv_asset
+    tra2 = ser_new_tra("serv_asset",sizeof(serv_asset),tra1);
+    ser_new_field(tra2,"serv_asset",1,"prev",offsetof(serv_asset,prev));
+    ser_new_field(tra2,"serv_asset",1,"next",offsetof(serv_asset,next));
+    ser_new_field(tra2,"time_t",0,"first_seen",offsetof(serv_asset,first_seen));
+    ser_new_field(tra2,"time_t",0,"last_seen",offsetof(serv_asset,last_seen));
+    ser_new_field(tra2,"ushort",0,"i_attempts",offsetof(serv_asset,i_attempts));
+    ser_new_field(tra2,"ushort",0,"proto",offsetof(serv_asset,proto));
+    ser_new_field(tra2,"uint16_t",0,"port",offsetof(serv_asset,port));
+    ser_new_field(tra2,"uint8_t",0,"ttl",offsetof(serv_asset,ttl));
+    ser_new_field(tra2,"tagstr",1,"service",offsetof(serv_asset,service));
+    ser_new_field(tra2,"tagstr",1,"application",offsetof(serv_asset,application));
+    ser_new_field(tra2,"int",0,"role",offsetof(serv_asset,role));
+    ser_new_field(tra2,"int",0,"unknown",offsetof(serv_asset,unknown));
+    
+    // translator for os_asset
+    tra3 = ser_new_tra("os_asset",sizeof(os_asset),tra2);
+    ser_new_field(tra3,"serv_asset",1,"prev",offsetof(os_asset,prev));
+    ser_new_field(tra3,"serv_asset",1,"next",offsetof(os_asset,next));
+    ser_new_field(tra3,"time_t",0,"first_seen",offsetof(os_asset,first_seen));
+    ser_new_field(tra3,"time_t",0,"last_seen",offsetof(os_asset,last_seen));
+    ser_new_field(tra3,"ushort",0,"i_attempts",offsetof(os_asset,i_attempts));
+    ser_new_field(tra3,"tagstr",1,"vendor",offsetof(os_asset,vendor));
+    ser_new_field(tra3,"tagstr",1,"os",offsetof(os_asset,os));
+    ser_new_field(tra3,"uint8_t",0,"detection",offsetof(os_asset,detection));
+    ser_new_field(tra3,"tagstr",1,"raw_fp",offsetof(os_asset,raw_fp));
+    ser_new_field(tra3,"tagstr",1,"matched_fp",offsetof(os_asset,matched_fp));
+    ser_new_field(tra3,"string",0,"match_os",offsetof(os_asset,match_os));
+    ser_new_field(tra3,"string",0,"match_desc",offsetof(os_asset,match_desc));
+    ser_new_field(tra3,"int16_t",0,"port",offsetof(os_asset,port));
+    ser_new_field(tra3,"int16_t",0,"mtu",offsetof(os_asset,mtu));
+    ser_new_field(tra3,"int8_t",0,"ttl",offsetof(os_asset,ttl));
+    ser_new_field(tra3,"int32_t",0,"uptime",offsetof(os_asset,uptime));
+ 
+    //translator for in6_addr
+    tra4 = ser_new_tra("in6", sizeof(uint8_t) * 4, tra3);
+    field = ser_new_field(tra4, "uint8_t", 0, "value", 0);
+    field->repeat = 4;
+    // #ifdef SER_DEBUG
+    //   ser_tra_list(tra0); 
+    //#endif
+}
diff -urN prads/src/prads.h prads-sdmbn/src/prads.h
--- prads/src/prads.h	2013-11-06 10:13:55.000000003 -0600
+++ prads-sdmbn/src/prads.h	2014-04-15 13:53:57.000000003 -0500
@@ -29,6 +29,8 @@
 #include <netinet/in.h>
 #include <pcre.h>
 
+#include "serialize.h"
+#include <pthread.h>
 /*  D E F I N E S  ************************************************************/
 #ifndef RELEASE
 #define RELEASE
@@ -179,6 +181,10 @@
 #define CXT_DEFAULT_HASHSIZE           65536
 #define CXT_DEFAULT_PREALLOC           10000
 
+#define TRANSFER_MULTI_FLOW            1 // transfer multi flow in per flow state
+
+pthread_mutex_t ConnEntryLock;
+pthread_mutex_t AssetEntryLock;
 /*  D A T A  S T R U C T U R E S  *********************************************/
 
 /*
@@ -454,7 +460,6 @@
 {
     uint16_t    af;            
     uint8_t     sre_offset;
-    uint8_t     sre_length;
     uint8_t     *routing;
 } gre_sre_header;
 
@@ -532,6 +537,7 @@
     uint8_t  check;               /* Flags spesifying checking */
     struct   _asset *c_asset;     /* pointer to src asset */
     struct   _asset *s_asset;     /* pointer to server asset */
+    uint32_t gotten;              /* last SDMBN get call that returned this. 0: not moved, -1: moved but don't raise event, >0: moved, raise event */
 } connection;
 #define CXT_DONT_CHECK_SERVER     0x01  /* Dont check server packets */
 #define CXT_DONT_CHECK_CLIENT     0x02  /* Dont check client packets */
@@ -658,6 +664,7 @@
     connection      *cxt;           /* pointer to the cxt for this packet */
     struct _asset    *asset;         /* pointer to the asset for this (src) packet */
     enum { SIGNATURE, FINGERPRINT } type;
+	bool drop_flag;					/* bit to indicate if packet is to be dropped */
 } packetinfo;
 
 // packetinfo accessor macros
@@ -731,6 +738,8 @@
     mac_entry *macentry;        /* Asset MAC vendor name */
     serv_asset *services;       /* Linked list with services detected */
     os_asset *os;               /* Linked list with OSes detected */
+    uint32_t ref;               /* No of connection records referencing this asset */
+    int sdmbn_msgid;       /* Sdmbn Msg id*/
 } asset;
 
 typedef struct _signature {
@@ -800,6 +809,13 @@
     uint32_t udp_clients;   /* total number of tcp clients detected */
 } prads_stat;
 
+typedef struct _tagstr {
+        int mlen;
+        int slen;
+        unsigned char * data;
+}tagstr;
+
+ser_tra_t *tra0,*head_tra; 
 
 #ifdef NO_VECTOR_TYPES
 typedef struct _fmask {
@@ -841,4 +857,6 @@
 // can't declare in sys_func.h because it does not include prads.h!
 const char *u_ntop_src(packetinfo *pi, char* dest);
 const char *u_ntop_dst(packetinfo *pi, char* dest);
+ser_tra_t* setup_serialize_translators();
+
 #endif                          // PRADS_H
diff -urN prads/src/SDMBNLocal.h prads-sdmbn/src/SDMBNLocal.h
--- prads/src/SDMBNLocal.h	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/src/SDMBNLocal.h	2014-04-15 13:53:57.000000003 -0500
@@ -0,0 +1,42 @@
+#ifndef _SDMBNLocal_H_
+#define _SDMBNLocal_H_
+
+#include <SDMBN.h>
+
+///// DEBUGGING MACROS ///////////////////////////////////////////////////////
+//#define SDMBN_SERIALIZE
+
+//#define SDMBN_INFO
+//#define SDMBN_ERROR
+
+#ifdef SDMBN_SERIALIZE
+    #define SERIALIZE_PRINT(...) printf(__VA_ARGS__); printf("\n");
+#else
+    #define SERIALIZE_PRINT(...)
+#endif
+
+#ifdef SDMBN_INFO
+    #define INFO_PRINT(...) printf(__VA_ARGS__); printf("\n");
+    #ifndef SDMBN_ERROR
+        #define SDMBN_ERROR
+    #endif
+#else
+    #define INFO_PRINT(...)
+#endif
+
+#ifdef SDMBN_ERROR
+    #define ERROR_PRINT(...) printf(__VA_ARGS__); printf("\n");
+#else
+    #define ERROR_PRINT(...)
+#endif
+
+///// FUNCTION PROTOTYPES ////////////////////////////////////////////////////
+int local_get_perflow(PerflowKey *key, int id, int raiseEvents);
+int local_put_perflow(int hashkey, PerflowKey *key, char *state);
+int local_get_shared(int id);
+int local_put_shared(int hashkey, char *state);
+int local_get_multiflow(PerflowKey *key, int id);
+int local_put_multiflow(int hashkey, PerflowKey *key, char *state);
+int local_del_multiflow(PerflowKey *key, int id, int force);
+int local_del_perflow(PerflowKey *key, int id);
+#endif
diff -urN prads/src/serialize.c prads-sdmbn/src/serialize.c
--- prads/src/serialize.c	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/src/serialize.c	2014-02-17 17:20:12.000000003 -0600
@@ -0,0 +1,4160 @@
+/*
+  serialize.c
+  C serialization library
+  version 0.4
+  ulf.astrom@gmail.com / happyponyland.net
+
+  This is a library for serializing structures in C.
+  Please see readme.html for more information.
+
+  Copyright (c) 2012, 2013 Ulf Åström
+
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any
+  damages arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any
+  purpose, including commercial applications, and to alter it and
+  redistribute it freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software. If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  2. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  3. This notice may not be removed or altered from any source
+     distribution.
+*/
+/*
+  ##doc-meta
+  #title C serialization library: Function reference
+  #catorder Translators
+  #catorder Fields
+  #catorder Serialization
+  #catorder Logging
+  #catorder Strings
+  #catorder Types
+  #catorder Internal
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <limits.h>
+
+#include "serialize.h"
+
+
+
+/**
+   Makes a new translator called @id for a structure @size bytes
+   large. If @att is non-NULL the new translator will be attached to
+   the end of that list of translators.
+   
+   Returns a pointer to the new translator or NULL on error.
+
+   #category Translators
+*/
+ser_tra_t * ser_new_tra(const char * id, const size_t size, ser_tra_t * att)
+{
+  ser_tra_t * tra;
+  char * dup_id;
+
+  if (!id || size < 0)
+    return NULL;
+
+  if (att && ser_find_tra(att, id))
+  {
+    SER_DPRINT("translator %s already exists\n", id);
+    return NULL;
+  }
+  
+  SER_DPRINT("creating translator %s (size %ld)\n", id, size);
+
+  tra = malloc(sizeof(ser_tra_t));
+  dup_id = strdup(id);
+
+  if (!tra || !dup_id)
+  {
+    free(tra);
+    free(dup_id);
+    return NULL;
+  }
+
+  tra->next = NULL;
+  tra->id = dup_id;
+  tra->size = size;
+  tra->atype = ser_flat;
+  tra->first_field = NULL;
+  tra->custom = NULL;
+  
+  /* Attach it at the end. */
+  if (att)
+  {
+    while (att->next != NULL)
+      att = att->next;
+
+    att->next = tra;
+  }
+
+  return tra;
+}
+
+
+
+/**
+   Deletes the translator @tra and all translators linked after it.
+
+   #category Translators
+*/
+void ser_del_tra(ser_tra_t * tra)
+{
+  ser_tra_t * tmp;
+
+  if (!tra)
+    return;
+
+  do
+  {
+    tmp = tra->next;
+
+    SER_DPRINT("deleting translator %s\n", tra->id);
+
+    ser_del_field(tra, tra->first_field);
+    
+    free(tra->id);
+    free(tra);
+
+    tra = tmp;
+  } while (tra);
+
+  return;
+}
+
+
+
+
+/**
+   Makes a new translator called @id that will be a dynamic
+   (variable-size, i.e. a pointer) array of @type@. If @att is
+   non-NULL the new translator will be attached to the end of that
+   list of translators.
+
+   Note: other translators referencing @id needs an array count field
+   to function properly.
+
+   Returns a pointer to the new translator or NULL on error.
+
+   #category Translators
+*/
+ser_tra_t * ser_new_dyn_array(const char * id, const char * type,
+			      const int ref, const size_t size, ser_tra_t * att)
+{
+  ser_tra_t * tra;
+  ser_field_t * field;
+
+  tra = ser_new_tra(id, size, att);
+
+  if (tra)
+  {
+    field = ser_new_field(tra, type, ref, "__internal__", 0);
+
+    if (!field)
+    {
+      ser_del_tra(tra);
+      return NULL;
+    }
+
+    field->repeat = 0;
+
+    tra->atype = ser_array_dynamic;
+
+    SER_DPRINT("new dynamic array %s, size %ld\n", tra->id, tra->size);
+  }
+
+  return tra;
+}
+
+
+
+/**
+   Makes a new translator called @id that will be a null-terminated
+   array of @type@. If @att is non-NULL the new translator will be
+   attached to the end of that list of translators.
+
+   Returns a pointer to the new translator or NULL on error.
+
+   #category Translators
+*/
+ser_tra_t * ser_new_nullterm_array(const char * id, const char * type,
+				   const int ref, ser_tra_t * att)
+{
+  ser_tra_t * tra;
+  ser_field_t * field;
+
+  tra = ser_new_tra(id, ser_field_size(NULL, type, ref), att);
+
+  if (tra)
+  {
+    field = ser_new_field(tra, type, ref, "__internal__", 0);
+
+    if (!field)
+    {
+      ser_del_tra(tra);
+      return NULL;
+    }
+
+    field->repeat = 0;
+
+    tra->atype = ser_array_nullterm;
+
+    SER_DPRINT("new null-terminated array %s\n", tra->id);
+  }
+
+  return tra;
+}
+
+
+
+/**
+   Returns the length of a null-terminated array of @type starting at
+   @thing@. Elements will be counted up to (and including) the first
+   that is zero.
+
+   #category Internal
+*/
+size_t ser_nullterm_len(void * thing, char * type)
+{
+  size_t el_w; /* element width */
+  size_t value;
+  size_t count;
+  void * ptr;
+
+  if (!thing || !type)
+    return 0;
+
+  count = 0;
+  el_w = ser_field_size(NULL, type, 0);
+
+  while (1)
+  {
+    ptr = thing + el_w * count;
+    value = ser_numeric_cast(ptr, type);
+
+    count++;
+
+    if (value == 0)
+      break;
+  }
+
+  return count;
+}
+
+
+
+/**
+   Adds field @tag to the translator @tra@. The field will be
+   serialized as @type@. If @ref is non-zero it will be made a
+   reference. @offset is the number of bytes between the start of the
+   structure and the start of the member field; it is recommended to
+   find this using offsetof().
+   
+   The field will not be created if a field with the same tag exists
+   in the translator or if the translator is defined as an array,
+   i.e. it was created with ser_new_dyn_array() or
+   ser_new_null_array() (see ser_tra_t.atype).
+   
+   Returns a pointer to the new field, or NULL on error.
+
+   #category Fields
+*/
+ser_field_t * ser_new_field(ser_tra_t * tra, const char * type, const int ref,
+			    const char * tag, const size_t offset)
+{
+  ser_field_t * field;
+  char * dup_type;
+  char * dup_tag;
+
+  if (!tra || !tag || !type)
+    return NULL;
+  
+  if (tra->atype != ser_flat)
+    return NULL;
+
+  if (ser_find_field(tra, tra->id, tag))
+    return NULL;
+
+  /* Set up the field structure */
+  field = malloc(sizeof(ser_field_t));
+  dup_type = strdup(type);
+  dup_tag = strdup(tag);
+
+  if (!field || !dup_type || !dup_tag)
+  {
+    free(dup_tag);
+    free(dup_type);
+    free(field);
+    return NULL;
+  }
+
+  field->tag = dup_tag;
+  field->type = dup_type;
+  field->offset = offset;
+  field->next = NULL;
+  field->repeat = 1;
+  field->ref = ref;
+
+  /*
+    Attach the field to the translator. If there are no fields in the
+    translators, put it as first field. If there are fields already,
+    put it at the end of the field list.
+  */
+  if (!tra->first_field)
+  {
+    tra->first_field = field;
+  } 
+  else
+  {
+    ser_field_t * temp;
+
+    temp = tra->first_field;
+    
+    while (temp->next != NULL)
+      temp = temp->next;
+
+    temp->next = field;
+  }
+
+  SER_DPRINT("added field %s %s->%s (offset %ld)\n",
+	     type, tra->id, tag, field->offset);
+
+  return field;
+}
+
+
+
+/**
+   Deletes @field from @tra and all fields linked after it.
+
+   #category Fields
+*/
+void ser_del_field(ser_tra_t * tra, ser_field_t * field)
+{
+  ser_field_t * tmp;
+  
+  if (!tra || !field)
+    return;
+
+  SER_DPRINT("deleting field %s->%s\n", tra->id, field->tag);
+
+  do
+  {
+    tmp = field->next;
+
+    free(field->tag);
+    free(field->type);
+    free(field);
+
+    field = tmp;
+  } while (field);
+
+  if (tra->first_field == field)
+    tra->first_field = NULL;
+  
+  return;
+}
+
+
+
+/**
+   Serializes translators. This function sets up translators for
+   ser_tra_t and ser_field_t; i.e. it describes the structure of the
+   translators themselves. If @tra is provided the translators in this
+   list will be serialized, otherwise the meta translators will be
+   serialized.
+
+   Returns the serialized translator(s).
+
+   #category Translators
+*/
+char * ser_meta_tra(ser_tra_t * tra)
+{
+  char * ret;
+  ser_tra_t * fmtra; /* first "meta" tra */
+  ser_tra_t * mtra; /* "meta" tra */
+
+  fmtra = mtra = ser_new_tra("translator", sizeof(ser_tra_t), NULL);
+  ser_new_field(mtra, "string",     0, "id",          offsetof(ser_tra_t, id));
+  ser_new_field(mtra, "int",        0, "atype",       offsetof(ser_tra_t, atype));
+  ser_new_field(mtra, "size_t",     0, "size",        offsetof(ser_tra_t, size));
+  ser_new_field(mtra, "translator", 1, "next",        offsetof(ser_tra_t, next));
+  ser_new_field(mtra, "field",      1, "first_field", offsetof(ser_tra_t, first_field));
+
+  mtra = ser_new_tra("field", sizeof(ser_field_t), fmtra);
+  ser_new_field(mtra, "string", 0, "tag",    offsetof(ser_field_t, tag));
+  ser_new_field(mtra, "string", 0, "type",   offsetof(ser_field_t, type));
+  ser_new_field(mtra, "int",    0, "ref",    offsetof(ser_field_t, ref));
+  ser_new_field(mtra, "field",  1, "next",   offsetof(ser_field_t, next));
+  ser_new_field(mtra, "size_t", 0, "offset", offsetof(ser_field_t, offset));
+  ser_new_field(mtra, "size_t", 0, "repeat", offsetof(ser_field_t, repeat));
+  
+  if (tra)
+    ret = ser_ialize(fmtra, "translator", tra, &ser_def_log, 0);
+  else
+    ret = ser_ialize(fmtra, "translator", fmtra, &ser_def_log, 0);
+
+  ser_del_tra(fmtra);
+
+  return ret;
+}
+
+
+
+/**
+   Prints (to stderr) the fields in @tra and all linked translators.
+
+   #category Translators
+*/
+void ser_tra_list(ser_tra_t * tra)
+{
+  ser_field_t * field;
+
+  while (tra)
+  {
+    fprintf(stderr, "translator %s", tra->id);
+    fprintf(stderr, "  /* size %ld */",  tra->size);
+    fprintf(stderr, "\n{\n");
+
+    for (field = tra->first_field; field; field = field->next)
+    {
+      fprintf(stderr, "  %s %s  ",
+	      field->type, field->tag);
+      
+      if (field->repeat)
+      {
+	fprintf(stderr, "  /* r=%ld %ld-%ld */",
+		field->repeat,
+		field->offset,
+		field->offset +
+		ser_field_size(NULL, field->type, field->ref) * field->repeat - 1);
+      }
+	      
+      fprintf(stderr, "\n");
+    }
+
+    fprintf(stderr, "}\n");
+
+    tra = tra->next;
+  }
+
+  return;
+}
+
+
+
+
+
+/**
+   Serializes @first as @type, using @tra as translator list (a
+   translator for @type must exist in @tra). Extra options can be
+   given as a bitmask in @options@; see SER_OPT_* for details.
+   
+   If @log_func is provided it will be called with error messages if
+   serialization fails. If it is NULL output will be muted. See
+   ser_def_log(). Implement your own to redirect output to a custom
+   logging console, etc.
+   
+   Returns a string (which must be freed after use) describing the
+   structure in human-readable format. Returns NULL on error.
+
+   #category Serialization
+*/
+char * ser_ialize(ser_tra_t * tra, char * type, void * first, 
+		  void (*log_func)(char *), uint16_t options)
+{
+  ser_tra_t * start_tra;
+  ser_job_t job;
+  char tmp[SER_MSGLEN];
+  size_t i;
+  bool failed = false;
+
+  if (/*!tra ||*/ !type)
+    return NULL;
+
+  /*
+    Instead of checking for the presence of a log function every time
+    we wish to print we will just redirect all output to the "null"
+    logger. Under normal operation this should not be called, so
+    performance isn't an issue.
+  */
+  if (log_func)
+    job.log_func = log_func;
+  else
+    job.log_func = &ser_null_log;
+
+  job.first_tra = tra;
+
+  job.options = options;
+  job.holder = NULL;
+  job.things = 2;
+  job.allocated = 0;
+
+  /* Output buffer */
+  job.result = NULL;
+  ser_job_realloc_result(&job, 0);
+  job.result[0] = '\0';
+
+  ser_job_realloc_holders(&job, 10);
+  ser_clear_holder(&job.holder[1]);
+
+  if (ser_is_primitive(type))
+  {
+    if (!ser_write_primitive(&job, 1, type, first))
+      goto error_cleanup;
+
+    goto finish;
+  }
+  else
+  {
+    start_tra = ser_find_tra(job.first_tra, type);
+    
+    if (start_tra == NULL)
+    {
+      snprintf(tmp, SER_MSGLEN, "warning: no translator for type %s", type);
+      job.log_func(tmp);
+      goto error_cleanup;
+    }
+  }
+  
+  job.holder[1].start = first;
+  job.holder[1].type = strdup(type);
+  job.holder[1].size = start_tra->size;
+
+  /*
+    Descend into the first structure and assign holders for all its
+    pointers. Each will be added to the same list so the loop won't
+    finish until all have been covered.
+  */
+  for (i = 1; i < job.things; i++)
+  {
+    SER_DPRINT("holder[%ld] (%ld)\n", i, job.things);
+
+    if (ser_follow_ptrs(&job, i, NULL, NULL) == 0)
+    {
+      SER_DPRINT("follow_ptrs failed!\n");
+      break;
+    }
+  }
+  
+  /* Check for pointers that overlap, redirect these if possible. */
+  ser_ptr_overlap(&job);
+
+  #ifdef SER_DEBUG
+  ser_list_holders(&job);
+  #endif
+
+  /* Keep writing structures until we've covered them all. */
+  SER_DPRINT("using %ld holders\n", job.things);
+
+  for (i = 1; i < job.things; i++)
+  {
+    size_t replace;
+
+    replace = job.holder[i].replace_id;
+
+    if (replace)
+    {
+/*      char tmp[SER_MSGLEN];
+      snprintf(tmp, SER_MSGLEN, "%s #%ld -> #%ld.%s;%s",
+	       job.holder[i].type, i,
+	       replace,
+               job.holder[i].replace_field,
+	       (job.options & SER_COMPACT ? "" : "\n"));
+	       ser_job_cat(&job, tmp);*/
+      continue;
+    }
+
+    if (ser_is_primitive(job.holder[i].type))
+    {
+      if (ser_write_primitive(&job, i, job.holder[i].type, job.holder[i].start) == 0)
+	break;
+    }
+    else if (ser_dump(&job, job.holder[i].type, job.holder[i].start) == 0)
+      break;
+  }
+
+finish:
+  
+  for (i = 1; i < job.things; i++)
+  {
+    free(job.holder[i].replace_field);
+  }
+
+  free(job.holder);
+
+  if (failed)
+  {
+    free(job.result);
+    return NULL;
+  }
+
+  return job.result;
+
+error_cleanup:
+  failed = true;
+  goto finish;
+}
+
+
+
+/**
+   Lists the holders in @job@; what they point to, size, type, element
+   count, redirections, etc.
+
+   #category Internal
+ */
+void ser_list_holders(ser_job_t * job)
+{
+  size_t i;
+
+  if (!job)
+    return;
+  
+  for (i = 1; i < job->things; i++)
+  {
+    SER_DPRINT("holder[%ld]:\n", i);
+    SER_DPRINT("->start == %p\n", job->holder[i].start);
+    SER_DPRINT("->size == %ld\n", job->holder[i].size);
+    SER_DPRINT("->elements == %ld\n", job->holder[i].elements);
+
+    if (job->holder[i].type)
+    {
+      SER_DPRINT("->type == %s\n", job->holder[i].type);
+    }
+    else
+    {
+      SER_DPRINT("->tra == NULL\n");
+    }
+
+    SER_DPRINT("->replace_id == %ld\n", job->holder[i].replace_id);
+
+    if (job->holder[i].replace_field)
+      SER_DPRINT("->replace_field == %s\n", job->holder[i].replace_field);
+  }
+
+  return;
+}
+
+
+
+/**
+   Scans @job for holders whose pointers overlap. If a holder is found
+   whose destination would fit within a another structure, it will be
+   marked as a redirected structure. This information will be used by
+   ser_ialize().
+
+   Returns non-zero on success, zero on failure.
+   
+   #category Internal
+*/
+void ser_ptr_overlap(ser_job_t * job)
+{
+  size_t things;
+  size_t i;
+
+  if (!job)
+    return;
+
+  SER_DPRINT("scanning for pointer overlap\n");
+
+  things = job->things;
+
+  for (i = 1; i < things; i++)
+  {
+    if (ser_make_reference(job, job->holder[i].start, job->holder[i].size, i, NULL))
+      job->holder[i].replace_id = 1;
+
+    continue;
+  }
+
+  return;
+}
+
+
+
+/**
+   Reallocates @job@s output buffer to @len characters. One extra byte
+   will be reserved for the terminator; this does not need to be
+   included in @len@.
+
+   Returns true on success, false on failure.
+
+   #category Internal
+*/
+bool ser_job_realloc_result(ser_job_t * job, const int len)
+{
+  char * new_result;
+
+  if (!job)
+    return false;
+
+  new_result = realloc(job->result, len + 1);
+
+  if (!new_result)
+  {
+    printf("\n\nshit\n\n");
+    exit(1);
+    return false;
+  }
+
+  job->result = new_result;
+  job->result_len = len;
+
+  return true;
+}
+
+
+/**
+   Concatenates @s to @job@s result buffer. Note that the buffer might be
+   moved and old pointers to it invalidated.
+   
+   Returns true on success, false on failure (bad pointers, memory
+   could not be allocated, etc).
+
+   #category Internal
+*/
+bool ser_job_cat(ser_job_t * job, char * s)
+{
+  int cat_len;
+  int old_len;
+
+  if (!job || !s)
+    return false;
+
+  old_len = job->result_len;
+  cat_len = strlen(s);
+
+  if (ser_job_realloc_result(job, old_len + cat_len) == 0)
+    return false;
+
+  strncpy(job->result + old_len, s, cat_len);
+
+  job->result[job->result_len] = '\0';
+  
+  return true;
+}
+
+
+/**
+   Finds the index of @thing in @job@s list of pointer holders, or adds it
+   if it isn't found. If the list is too small to hold the addition it
+   will be resized aggressively.
+   
+   Returns the index assigned or 0 on error.
+   
+   #category Internal
+*/
+size_t ser_assign_holder(ser_job_t * job, void * thing, size_t size)
+{
+  int n;
+
+  if (!job || !thing)
+    return 0;
+
+  n = ser_find_holder(job, thing, size);
+
+  if (n)
+    return n;
+
+  /* It isn't in the list. Make sure there's room to add it. */
+
+  if (job->things >= job->allocated)
+  {
+    if (ser_job_realloc_holders(job, job->allocated * 2) == 0)
+      return 0;
+  }
+
+  n = job->things;
+
+  SER_DPRINT("assigning holder[%d].start %p\n", n, thing);
+
+  job->holder[n].start = thing;
+  job->things++;
+
+  return n;
+}
+
+
+/**
+   Returns the index of the holder in @job pointing to @thing@, or 0
+   if it could not be found.
+
+   See also: ser_assign_holder
+
+   #category Internal
+*/
+size_t ser_find_holder(ser_job_t * job, void * thing, size_t size)
+{
+  int i;
+
+  if (!job || !thing)
+    return 0;
+
+  for (i = 1; i < job->things; i++)
+  {
+    if (job->holder[i].start == thing)
+    {
+      if (size == 0 || size == job->holder[i].size)
+	return i;
+    }
+  }
+
+  return 0;
+}
+
+
+/**
+   Serializes a primitive value and adds it to @job@s output
+   buffer. @holder is the index of the value; @type is
+   self-explanatory and @field_ptr is the start of the memory to be
+   translated.
+
+   Returns true on success, false on failure.
+
+   #category Internal
+*/
+bool ser_write_primitive(ser_job_t * job, const size_t holder,
+			const char * type, void * field_ptr)
+{
+  char tmp[SER_MSGLEN];
+
+  if (!job || !type || !field_ptr)
+    return false;
+
+  snprintf(tmp, SER_MSGLEN, "%s #%ld%s",
+	   type, holder,
+	   (job->options & SER_OPT_COMPACT ? "{" : "\n{\n  "));
+  ser_job_cat(job, tmp);
+
+  ser_write_value(job, type, 0, field_ptr);
+
+  ser_job_cat(job, (job->options & SER_OPT_COMPACT ? "}" : "\n}\n"));
+  
+  return true;
+}
+
+
+
+/**
+   Converts @thing to human-readable text, according to the translator
+   for @type present in @job. The result will be appended to the output
+   buffer in @job.
+
+   Returns true if @thing could be translated properly, false if
+   something went wrong.
+   
+   #category Internal
+*/
+bool ser_dump(ser_job_t * job, char * type, void * thing)
+{
+  ser_tra_t * tra;
+  size_t holder_index;
+  char tmp[SER_MSGLEN];
+
+  /* Find the translator for the thing */
+  tra = ser_find_tra(job->first_tra, type);
+
+  if (tra == NULL)
+  {
+    snprintf(tmp, SER_MSGLEN, "/* unknown type %s */\n", type);
+    ser_job_cat(job, tmp);
+    return false;
+  }
+  
+  holder_index = ser_find_holder(job, thing, tra->size);
+
+  if (holder_index == 0)
+    return false;
+
+  if (ser_write_struct(job, tra, holder_index, thing, 0) == 0)
+    return false;
+
+  return true;
+}
+
+
+
+/**
+   Adds to @job@s output buffer a textual representation of the
+   structure located at @thing@ serialized using @tra@.
+
+   @ptr_index should be the index of the holder pointing to @thing@ or
+   zero if @thing does not have any memory allocation of its own
+   (e.g. it is an anonymous sub-structure).
+
+   Returns true if everything went o-kay, false if something broke.
+   
+   #category Internal
+*/
+bool ser_write_struct(ser_job_t * job, ser_tra_t * tra,
+		      size_t ptr_index, void * thing, const int anon)
+{
+  char tmp[SER_MSGLEN];
+  size_t repeat;
+  int compact;
+  ser_field_t * field;
+  void * array_start;
+
+  SER_DPRINT("writing struct %s holder[%ld] @ %p\n", tra->id, ptr_index, thing);
+
+  compact = job->options & SER_OPT_COMPACT;
+
+  /*
+    If this is an anonymous structure (embedded within another
+    structure) we don't want to print the type and reference id
+    (in fact, they shouldn't have any holder at all!).
+  */
+  if (!anon)
+  {
+    snprintf(tmp, SER_MSGLEN, "%s #%ld%s",
+	     tra->id, ptr_index,
+	     (compact ? "" : "\n"));
+    ser_job_cat(job, tmp);
+  }
+
+  if (!anon)
+    sprintf(tmp, "{%s", (compact ? "" : "\n"));
+  else
+    sprintf(tmp, "{%s", (compact ? "" : " "));
+
+  ser_job_cat(job, tmp);
+
+
+  for (field = tra->first_field; field; field = field->next)
+  {
+    /*
+      Get the number of elements to write. For dynamic arrays this
+      should have been filled in from the array count field. For
+      null-terminated arrays we will calculate this now. For static
+      arrays just use the field repeat count.
+    */    
+    if (tra->atype == ser_array_dynamic)
+      repeat = job->holder[ptr_index].elements;
+    else if (tra->atype == ser_array_nullterm)
+      repeat = ser_nullterm_len(thing, field->type);
+    else
+      repeat = field->repeat;
+
+    SER_DPRINT("%s %s, repeat %ld\n", field->type, field->tag, repeat);
+    
+    /*
+      Don't write dynamic arrays if we don't know where they
+      end. Don't write array count fields (they are useless; we will
+      get that information from parsing the array anyway).
+    */
+    if (field->tag[0] == '@' || repeat == 0)
+      continue;
+    
+    if (!compact && !anon)
+      ser_job_cat(job, "  ");
+    
+    array_start = thing + field->offset;
+
+    if (ser_write_array(job, tra, field, array_start, repeat) == 0)
+      return false;
+
+    if (!compact)
+      ser_job_cat(job, (anon ? " " : "\n"));
+  }
+
+  if (tra->custom)
+    tra->custom(job, tra, thing);
+  
+  ser_job_cat(job, (compact ? "}" : (anon ? "}" : "}\n") ));
+  
+  return true;
+}
+
+
+
+/**
+   Sets the number of elements for holder @holder_index in @job to
+   @elements@.
+   
+   Returns true on success, false on error (in which case
+   @holder_index was probably outside the allocated range).
+
+   #category Internal
+*/
+bool ser_set_holder_elements(ser_job_t * job, size_t holder_index, size_t elements)
+{
+  if (!job || !holder_index || holder_index > job->allocated)
+    return false;
+    
+  job->holder[holder_index].elements = elements;
+
+  return true;
+}
+
+
+
+/**
+   Looks for a holder in @job that points to @start@ and a field in
+   @tra that is the array count field of @field@ (same name, prepended
+   by an at sign). If both are found the holder element count will be set to
+   the array count field value. @thing is the structure referencing
+   @start@; i.e. @thing has one or more pointers to @start that are
+   also registered in the translator.
+
+   Returns true if the field was found and the holder count set, false
+   if it could not be found or an error occured.
+
+   #category Internal
+ */
+bool ser_element_count(ser_job_t * job, ser_tra_t * tra,
+			 ser_field_t * field, void * thing, void * start)
+{
+  ser_field_t * count_field;
+  size_t holder_index;
+  size_t c;
+
+  holder_index = ser_find_holder(job, *(void**)start, 0);
+  
+  if (holder_index == 0)
+    return false;
+
+  count_field = ser_find_array_count(tra, field->tag);
+  
+  if (count_field == 0)
+  {
+    SER_DPRINT("no count field found for %s\n", field->tag);
+    return false;
+  }
+
+  c = ser_numeric_cast(thing + count_field->offset, count_field->type);
+
+  ser_set_holder_elements(job, holder_index, c);
+  
+  SER_DPRINT("using count field %s = %ld\n", count_field->tag, c);
+
+  return true;
+}
+
+
+
+/**
+   Writes @elements fields, starting at @array_start@, to @job@s
+   output buffer. @tra should be the type of container structure and
+   @field the type of output.
+
+   Returns true if the array could be written, false on error.
+
+   #category Internal
+*/
+bool ser_write_array(ser_job_t * job, ser_tra_t * tra, ser_field_t * field,
+		     void * array_start, size_t elements)
+{
+  char tmp[SER_MSGLEN];
+  size_t i;
+  void * field_ptr;
+
+  if (!job || !field || !array_start)
+    return false;
+
+  SER_DPRINT("writing array: %s:%s * %ld, start %p\n",
+	     tra->id, field->type, elements, array_start);
+ 
+  if (tra->atype == ser_flat)
+  {
+    snprintf(tmp, SER_MSGLEN, "%s ", field->tag);
+    ser_job_cat(job, tmp);
+    
+    if (elements != 1)
+      ser_job_cat(job, "{");
+  }
+    
+  for (i = 0; i < elements; i++)
+  {
+    field_ptr = array_start + ser_field_size(job, field->type, field->ref) * i;
+    
+    SER_DPRINT("-- array index %ld\n", i);
+
+    if (ser_write_value(job, field->type, field->ref, field_ptr) == 0)
+      return false;
+ 
+    if (elements != 1 && i < elements - 1)
+      ser_job_cat(job, (job->options & SER_OPT_COMPACT ? "," : ", "));
+  }
+
+  if (tra->atype == ser_flat)
+  {
+    if (elements != 1)
+      ser_job_cat(job, "}");
+    
+    ser_job_cat(job, ";");
+  }
+  
+  return true;
+}
+
+
+/**
+   Sets the custom output handler for @tra to @func_ptr@. There can
+   only be one such function per translator; if multiple calls are
+   needed (for OO-like functionality) a wrapper function is needed.
+
+   #category Internal
+*/
+void ser_set_custom_handler(ser_tra_t * tra,
+			    int (*func_ptr)(ser_job_t *, ser_tra_t *, void *))
+{
+  if (!tra || !func_ptr)
+    return;
+
+  tra->custom = func_ptr;
+
+  return;
+}
+
+
+/**
+   Attempts to convert the data at @ptr into a @type number. No type
+   or overflow checking is performed.
+
+   Returns the number (0 on error).
+
+   #category Internal
+*/
+long ser_numeric_cast(void * ptr, char * type)
+{
+  if (!ptr || !type)
+    return 0;
+
+  if (strcmp(type, "char") == 0)
+    return *(char*)ptr;
+  else if (strcmp(type, "short") == 0)
+    return *(short*)ptr;
+  else if (strcmp(type, "ushort") == 0)
+    return *(unsigned short*)ptr;
+  else if (strcmp(type, "int") == 0)
+    return *(int*)ptr;
+  else if (strcmp(type, "uint") == 0)
+    return *(unsigned int*)ptr;
+  else if (strcmp(type, "long") == 0)
+    return *(long*)ptr;
+  else if (strcmp(type, "ulong") == 0)
+    return *(unsigned long*)ptr;
+  else if (strcmp(type, "int8_t") == 0)
+    return *(int8_t*)ptr;
+  else if (strcmp(type, "uint8_t") == 0)
+    return *(uint8_t*)ptr;
+  else if (strcmp(type, "int16_t") == 0)
+    return *(int16_t*)ptr;
+  else if (strcmp(type, "uint16_t") == 0)
+    return *(uint16_t*)ptr;
+  else if (strcmp(type, "int32_t") == 0)
+    return *(int8_t*)ptr;
+  else if (strcmp(type, "uint32_t") == 0)
+    return *(int8_t*)ptr;
+  else if (strcmp(type, "intptr_t") == 0)
+    return *(intptr_t*)ptr;
+  else if (strcmp(type, "size_t") == 0)
+    return *(size_t*)ptr;
+  else if (strcmp(type, "time_t") == 0)
+    return *(time_t*)ptr;
+
+  SER_DPRINT("warning: unknown cast \"%s\"; returning 0\n", type);
+
+  return 0;
+}
+
+
+
+/**
+   Returns a pointer to any field in @tra that is an array count for
+   @array_tag; i.e. one that is @array_tag prepended with a @.
+
+   #category Internal
+*/
+ser_field_t * ser_find_array_count(ser_tra_t * tra, char * array_tag)
+{
+  ser_field_t * f;
+
+  if (!tra || !array_tag)
+    return NULL;
+
+  for (f = tra->first_field; f; f = f->next)
+  {
+    if (f->tag[0] == '@' && strcmp(f->tag + 1, array_tag) == 0)
+      return f;
+  }
+
+  return NULL;
+}
+
+
+
+/**
+   Searches @thing for reference fields and adds their destination to
+   @job@s list of holders. If @holder_index is non-zero the type
+   specified for that holder will be used as translator, otherwise
+   @thing_tra must be provided.
+
+   Returns true on success, false on utter, catastrophic failure.
+
+   #category Internal
+*/
+bool ser_follow_ptrs(ser_job_t * job, size_t holder_index,
+		     ser_tra_t * thing_tra, void * thing)
+{
+  char tmp[SER_MSGLEN];
+  ser_field_t * field;
+  void * field_ptr;
+  void * array_start;
+  char * type;
+  size_t i;
+  size_t repeat;
+  size_t el_size;
+
+  if (!job)
+    return false;
+
+  if (holder_index)
+  {
+    if (holder_index > job->allocated)
+      return false;
+
+    type = job->holder[holder_index].type;
+
+    if (ser_is_primitive(type))
+    {
+      SER_DPRINT("holder[%ld] is primitive (%s); skipping\n", holder_index, type);
+      return true;
+    }
+    
+    thing_tra = ser_find_tra(job->first_tra, type);
+    thing = job->holder[holder_index].start;
+  }
+
+  if (!thing || !thing_tra)
+    return false;
+  
+  if (holder_index)
+    SER_DPRINT("using holder %ld; ", holder_index);
+
+  SER_DPRINT("following pointers in %s at %p\n", thing_tra->id, thing);
+
+  /*
+    Scan each field in the translator.
+  */
+  for (field = thing_tra->first_field; field; field = field->next)
+  {
+    el_size = ser_field_size(job, field->type, field->ref);
+    array_start = thing + field->offset;
+
+    SER_DPRINT("-- field %s %s: ", field->type, field->tag);
+
+    /* These are of no relevance at this point. */
+    if (field->tag[0] == '@')
+    {
+      SER_DPRINT("array count, skipping\n");
+      continue;
+    }
+
+    if (thing_tra->atype == ser_array_dynamic ||
+	thing_tra->atype == ser_array_nullterm)
+    {
+      /*
+	If we get a dynamic array we must use its element count to
+	cover everything. This might be an array of pointers or an
+	array of structures containing pointers. This should only
+	process a single field.
+      */
+      if (field->next)
+      {
+	SER_DPRINT("%s is dynamic array but has more than one field\n", thing_tra->id);
+	break;
+      }
+
+      SER_DPRINT("using repeat %ld\n", repeat);
+      repeat = job->holder[holder_index].elements;
+    }
+    else if (thing_tra->atype == ser_flat)
+    {
+      /* It's just a regular structure. */
+      repeat = field->repeat;
+    }
+
+    if (!field->ref && !ser_is_primitive(field->type))
+    {
+      /*
+	It's an anonymous structure within thing. We won't add this
+	one to the holder list since it shares memory with the parent,
+	but we will recursively scan it for more pointers.
+      */
+
+      SER_DPRINT("anonymous struct\n");
+
+      ser_tra_t * anon_tra;
+      anon_tra = ser_find_tra(job->first_tra, field->type);
+      
+      if (!anon_tra && !ser_is_primitive(field->type))
+      {
+	snprintf(tmp, SER_MSGLEN,
+		 "warning: no translator for type %s", field->type);
+	job->log_func(tmp);
+	return false;
+      }
+
+      SER_DPRINT("-- -- using translator %s (size %ld)\n", anon_tra->id, el_size);
+      
+      /* Descend into the anonymous structure and see if it has any references. */
+      for (i = 0; i < repeat; i++)
+      {
+	field_ptr = array_start + el_size * i;
+	ser_follow_ptrs(job, 0, anon_tra, field_ptr);
+      }
+	
+      continue;
+    }
+    else if (field->ref)
+    {
+      /*
+	This field is a pointer.
+      */
+
+      SER_DPRINT("reference\n");
+
+      size_t target_index;
+      size_t target_size;
+
+      for (i = 0; i < repeat; i++)
+      {
+	field_ptr = array_start + el_size * i;
+	
+	if (*(void **)field_ptr == NULL)
+	{
+	  SER_DPRINT("NULL pointer; skipping...\n");
+	  continue;
+	}
+	
+	/*
+	  Find out how large the size of the destination area needs to
+	  be. We need to know this so ser_assign_holder can keep
+	  pointers of different size apart and so ser_ptr_overlap can
+	  perform overlap checking. field_size has 0 for reference
+	  so get the size of the target, not the pointer itself.
+	*/
+	target_size = ser_field_size(job, field->type, 0);
+
+	/* Put the pointer destination in a holder */
+	target_index = ser_assign_holder(job, *(void **)field_ptr, target_size);
+	
+	if (!target_index)
+	{
+	out_of_memory:
+	  snprintf(tmp, SER_MSGLEN,
+		   "error: out of memory");
+	  job->log_func(tmp);
+	  return false;
+	}
+
+	/*
+	  Register what the structure is.
+	*/
+	job->holder[target_index].size = target_size;
+
+	job->holder[target_index].type = strdup(field->type);
+
+	if (!job->holder[target_index].type)
+	  goto out_of_memory;
+
+	/*
+	  Finally, find out how _many_ thing_tra
+	  are supposed to be at thing.
+	*/
+	ser_element_count(job, thing_tra, field, thing, field_ptr);
+
+	SER_DPRINT("holder[%ld]: %s is %s (size %ld) ref to %p\n",
+		   target_index, field->tag, field->type, target_size, thing);
+      }
+
+      continue;
+    }
+
+    SER_DPRINT("nothing to do\n");
+  }
+  
+  return true;
+}
+
+
+
+/*
+  WIP
+
+  #category Internal
+*/
+bool ser_make_reference(ser_job_t * job, const void * thing,
+			const size_t size, const size_t skip,
+			char ** dest)
+{
+  size_t hi;
+  char * tag;
+  size_t ai;
+  size_t hsz;
+  size_t fsz;
+  uintptr_t pos;
+  uintptr_t start;
+  uintptr_t elpos;
+  ser_tra_t * tra;
+  ser_field_t * field;
+  ser_holder_t * holder;
+
+  char * ret;
+
+   if (!job || !thing)
+    return false;
+
+  pos = (uintptr_t)thing;
+
+  for (hi = 1; hi < job->allocated; hi++)
+  {
+    if (hi == skip)
+      continue;
+
+    holder = &job->holder[hi];
+    hsz = holder->size;
+    start = (uintptr_t)holder->start;
+
+    if (pos < start || pos >= start + hsz)
+      continue;
+
+    /* thing points within this structure. */
+
+    /* Does it point to the structure itself? */
+    if (size == hsz && pos == start)
+    {
+      tag = NULL;
+      ai = 0;
+      goto found_it;
+    }
+    
+    /* Check each field. */
+    tra = ser_find_tra(job->first_tra, holder->type);
+
+    if (!tra)
+      continue;
+
+    for (field = tra->first_field; field != NULL; field = field->next)
+    {
+      fsz = ser_field_size(job, field->type, field->ref);
+      
+      if (fsz != size)
+	continue;
+
+      for (ai = 0; ai < field->repeat; ai++)
+      {
+	elpos = start + field->offset + (ai * fsz);
+
+	if (elpos == pos)
+	{
+	  tag = field->tag;
+	  goto found_it;
+	}
+      }
+    }
+  }
+
+  /* Didn't find it */
+  return false;
+
+found_it:
+
+  if (dest == NULL)
+    return true;
+
+  char * p;
+
+  ret = malloc(1000);
+  sprintf(ret, "#%ld", hi);
+  
+  p = ret;
+  while (*p) p++;
+
+  if (tag)
+  {
+    *p++ = '.';
+    *p = '\0';
+    strcat(p, tag);
+
+    if (ai)
+    {
+      while (*p) p++;
+      sprintf(p, "[%ld]", ai);
+    }
+  }
+
+  *dest = ret;
+
+  return true;
+}
+
+
+
+
+/**
+   Appends to @job@s output buffer a textual representation of @field_ptr
+   as a @type. If the field is a reference, it will also register in
+   @job@s "holder" list what type of translation to use for the
+   destination structure in the future.
+
+   Returns true if the value could be written properly, false on error.
+
+   #category Internal
+*/
+bool ser_write_value(ser_job_t * job, const char * type,
+		     const int ref, void * field_ptr)
+{
+  char tmp[200];
+
+  tmp[0] = '\0';
+
+  SER_DPRINT("ref: %d\n", ref);
+
+  if (!job || !type || !field_ptr)
+    return false;
+
+  if (strcmp(type, "string") == 0)
+  {
+    if (*(char **)field_ptr == NULL)
+    {
+      ser_job_cat(job, "NULL");
+    }
+    else
+    {
+      char * esc;
+      esc = ser_escape_str(*(char **)field_ptr);
+      ser_job_cat(job, "\"");
+      ser_job_cat(job, esc);
+      ser_job_cat(job, "\"");
+      free(esc);
+    }
+    return 1;
+  }
+  else if (ref == 1)
+  {
+    if (*(void**)field_ptr == NULL)
+    {
+      sprintf(tmp, "NULL");
+    }
+    else
+    {
+      char * refstr;
+      bool r;
+      
+      r = ser_make_reference(job, *(void **)field_ptr,
+			     ser_field_size(job, type, 0), 0, &refstr);
+      
+      if (!r)
+      {
+	ser_list_holders(job);
+
+	sprintf(tmp, "error: missing reference for %s", type);
+	job->log_func(tmp);
+	return false;
+      }
+
+      sprintf(tmp, refstr);
+      free(refstr);
+    }
+  }
+  else if (strcmp(type, "bool") == 0)
+  {
+    if (*(bool*)field_ptr)
+      strcpy(tmp, "true");
+    else
+      strcpy(tmp, "false");
+  }
+  else if (strcmp(type, "short") == 0)
+    sprintf(tmp, "%d", *(short *)field_ptr);
+  else if (strcmp(type, "ushort") == 0)
+    sprintf(tmp, "%u", *(ushort *)field_ptr);
+  else if (strcmp(type, "int") == 0)
+    sprintf(tmp, "%d", *(int *)field_ptr);
+  else if (strcmp(type, "uint") == 0)
+    sprintf(tmp, "%u", *(unsigned int *)field_ptr);
+  else if (strcmp(type, "long") == 0)
+    sprintf(tmp, "%ld", *(long *)field_ptr);
+  else if (strcmp(type, "ulong") == 0)
+    sprintf(tmp, "%lu", *(unsigned long *)field_ptr);
+  else if (strcmp(type, "uint8_t") == 0)
+    sprintf(tmp, "%d", *(uint8_t *)field_ptr);
+  else if (strcmp(type, "uint16_t") == 0)
+    sprintf(tmp, "%d", *(uint16_t *)field_ptr);
+  else if (strcmp(type, "uint32_t") == 0)
+    sprintf(tmp, "%d", *(uint32_t *)field_ptr);
+  else if (strcmp(type, "int8_t") == 0)
+    sprintf(tmp, "%d", *(int8_t *)field_ptr);
+  else if (strcmp(type, "int16_t") == 0)
+    sprintf(tmp, "%d", *(int16_t *)field_ptr);
+  else if (strcmp(type, "int32_t") == 0)
+    sprintf(tmp, "%d", *(int32_t *)field_ptr);
+  else if (strcmp(type, "intptr_t") == 0)
+    sprintf(tmp, "%ld", *(intptr_t *)field_ptr);
+  else if (strcmp(type, "time_t") == 0)
+    sprintf(tmp, "%ld", *(time_t *)field_ptr);
+  else if (strcmp(type, "size_t") == 0)
+    sprintf(tmp, "%lu", *(size_t *)field_ptr);
+  else if (strcmp(type, "float") == 0)
+    sprintf(tmp, "%e", *(float *)field_ptr);
+  else if (strcmp(type, "double") == 0)
+    sprintf(tmp, "%le", *(double *)field_ptr);
+  else if (strcmp(type, "ldouble") == 0)
+    sprintf(tmp, "%Le", *(long double *)field_ptr);
+  else if (strcmp(type, "char") == 0)
+  {
+    int c;
+    
+    c = (*(char *)field_ptr) % 256;
+    
+    /* Escape non-printable characters */
+    if (isprint(c))
+      sprintf(tmp, "'%c'", c);
+    else
+      sprintf(tmp, "'\\x%02X'", c);
+  }
+  else if (ref == 0)
+  {
+    ser_tra_t * anon_tra;
+
+    anon_tra = ser_find_tra(job->first_tra, type);
+
+    if (!anon_tra)
+    {
+      sprintf(tmp, "warning: no translator for type %s", type);
+      job->log_func(tmp);
+      return false;
+    }
+    else
+    {
+      ser_write_struct(job, anon_tra, 0, field_ptr, 1);
+    }
+  }
+  else
+  {
+    sprintf(tmp, "/* error: bad field %s */", type);
+    ser_job_cat(job, tmp);
+
+    sprintf(tmp, "error: bad field %s", type);
+    job->log_func(tmp);
+    return 0;
+  }
+
+  ser_job_cat(job, tmp);
+
+  return true;
+}
+
+
+
+
+/**
+   Resizes the holder list of @job to @n elements. If the list is
+   expanded, new entries will be cleared.
+
+   Returns true on success, false on failure.
+
+   #category Internal
+*/
+bool ser_job_realloc_holders(ser_job_t * job, const int n)
+{
+  ser_holder_t * new_holder;
+  int old_n;
+  int i;
+
+  if (!job)
+    return false;
+
+  old_n = job->allocated;
+  job->allocated = n;
+
+  SER_DPRINT("allocating %d holders for job\n", n);
+
+  new_holder = realloc(job->holder, sizeof(ser_holder_t) * n);
+
+  if (!new_holder)
+    return false;
+
+  job->holder = new_holder;
+
+  /* Clear the resized array */
+  for (i = old_n; i < job->allocated; i++)
+  {
+    SER_DPRINT("clearing holder #%d\n", i);
+    ser_clear_holder(&job->holder[i]);
+  }
+
+  return true;
+}
+
+
+
+/**
+   Clears @holder@. This will not free any pointers associated with
+   it, only reset them to neutral values.
+
+   #category Internal
+*/
+void ser_clear_holder(ser_holder_t * holder)
+{
+  if (!holder)
+    return;
+
+  holder->start = NULL;
+  holder->type = NULL;
+  holder->elements = 0;
+  holder->replace_id = 0;
+  holder->replace_field = NULL;
+  holder->size = 0;
+
+  return;
+}
+
+
+
+/**
+   Default error logger. Implement your own and pass it to ser_ialize()
+   and ser_parse() to redirect errors to your custom logging console,
+   message boxes, etc.
+
+   #category Logging
+*/
+void ser_def_log(char * msg)
+{
+  fprintf(stderr, "%s\n", msg);
+
+  return;
+}
+
+
+/**
+   Discards messages. This is where "muted" output ends up.
+
+   #category Logging
+*/
+void ser_null_log(char * msg)
+{
+  return;
+}
+
+
+/**
+   Creates a copy of @s suitable for ser_parse. Semicolons, commas,
+   braces outside quotes will be padded with spaces.
+
+   Returns the padded string or NULL on error.
+
+   #category Strings
+*/
+char * ser_preformat(char * s)
+{
+  char * pos;
+  char * ret;
+  char * d;
+
+  int count;
+  int quote;
+  int comment;
+  
+  if (!s)
+    return NULL;
+
+  count = 0;
+  quote = 0;
+  comment = 0;
+
+  pos = s;
+
+  while (*pos != '\0')
+  {
+    if (comment)
+    {
+      if (*pos == '*' && *(pos + 1) == '/')
+      {
+	pos += 2;
+	count += 3;
+	comment = 0;
+      }
+      else
+      {
+	pos++;
+	count++;
+      }
+    }
+    else if (*pos == '\"')
+    {
+      /*
+	If we encounter a quote character without a \ in front,
+	flip the quote flag to keep track we're in a string.
+      */
+      count++;
+      pos++;
+      quote = !quote;
+    }
+    else if (!quote && *pos == '/' && *(pos + 1) == '*')
+    {
+      comment = 1;
+      count += 3;
+      pos += 2;
+    }
+    else if (quote && *pos == '\\')
+    {
+      /*
+	Quotes after a slash are escaped, but only
+	if they themselves are within quotes.
+      */
+      count++;
+      pos++;
+    
+      if (*pos == '\"' || *pos == '\\')
+      {
+	count++;
+	pos++;
+      }
+    }
+    else if ((*pos == ';' || *pos == ',' || *pos == '{' || *pos == '}') && !quote)
+    {
+      /*
+	Add two extra bytes for spaces around
+	terminators, separators and braces.
+      */
+      count += 3;
+      pos++;
+    }
+    else
+    {
+      count++;
+      pos++;
+    }
+  }
+
+  count++; /* Termination character */
+
+  SER_DPRINT("ser_preformat(): original %d, new %d\n", (int)strlen(s), count);
+
+  ret = malloc(count);
+
+  if (ret == NULL)
+    return NULL;
+
+  quote = 0;
+  d = ret;
+  pos = s;
+
+  /*  */
+  while (*pos != '\0')
+  {
+    if (comment)
+    {
+      if (*pos == '*' && *(pos + 1) == '/')
+      {
+	*d++ = *pos++;
+	*d++ = *pos++;
+	*d++ = ' ';
+
+	comment = 0;
+      }
+      else
+      {
+	*d++ = *pos++;
+      }
+    }
+    else if (*pos == '\"')
+    {
+      quote = !quote;
+      *d++ = *pos++;
+    }
+    else if (!quote && *pos == '/' && *(pos + 1) == '*')
+    {
+      *d++ = ' ';
+      *d++ = *pos++;
+      *d++ = *pos++;
+    }
+    else if (*pos == '\\' && quote)
+    {
+      *d++ = *pos++;
+      
+      if (*pos == '\"' || *pos == '\\')
+      {
+	*d++ = *pos++;
+      }
+    }
+    else if ((*pos == ';' || *pos == ',' || *pos == '{' || *pos == '}') && !quote)
+    {
+      *d++ = ' ';
+      *d++ = *pos;
+      *d++ = ' ';
+      pos++;
+    }
+    else
+    {
+      *d++ = *pos++;
+    }
+  }
+
+  /* Terminate the new string */
+  *d = '\0';
+
+  return ret;
+}
+
+
+
+/**
+   Parses (inflates) @s according to the translator list
+   @first_tra. @expected_type should specify the type to expect for
+   index #1; if it differs the process will fail.
+   
+   If @log_func is provided it will be called with error messages
+   if inflation fails. If it is NULL output will be muted.
+   See ser_def_log().
+   
+   Returns a pointer to element #1 (correspondingly passed as @first to
+   ser_ialize()) or NULL on failure.
+
+   #category Serialization
+*/
+void * ser_parse(ser_tra_t * first_tra, const char * expected_type,
+		 char * s, void (*log_func)(char*))
+{
+  ser_job_t job;
+  char line[SER_MSGLEN];
+
+  void * first;
+  char * type;
+  char * tok;
+  ser_tok_t r;
+  ser_tra_t * tra;
+  long int tmp;
+  long int id;
+
+  first = NULL;
+
+  if (/*!first_tra ||*/ !s)
+    return NULL;
+
+  job.first_tra = first_tra;
+
+  if (log_func)
+    job.log_func = log_func;
+  else
+    job.log_func = &ser_null_log;
+  
+  SER_DPRINT("parse: start parsing\n");
+
+  job.first_sptr = NULL;
+  job.holder = NULL;
+  job.things = 0;
+  job.allocated = 0;
+
+  /*
+    We always want to allocate at least 1 holder. If there is no input
+    to parse, we will still return index 1 (that should be NULL).
+  */
+  ser_job_realloc_holders(&job, 1);
+  
+  job.p_str = ser_preformat(s);
+  
+  if (job.p_str == NULL)
+    return NULL;
+  
+  job.p_pos = job.p_str;
+  job.p_end = strchr(job.p_str, '\0');
+  
+  do
+  {
+    /* First we would like to know what kind of type we should inflate. */
+    
+    SER_DPRINT("parse: expecting type (or end of input)...\n");
+  
+    r = ser_ntok(&job, &type, &tmp);
+
+    if (r == ser_tok_end)
+    {
+      /* We have reached the end of the input. No more need for parsing. */
+      goto count_stuff;
+    }
+    else if (r != ser_tok_any)
+    {
+      /* We received something that clearly isn't a type. */
+      snprintf(line, SER_MSGLEN, "error: expecting type at byte %ld, got %s",
+	       job.p_byte, ser_token_code(r));
+      job.log_func(line);
+      goto cleanup;
+    }
+
+    SER_DPRINT("parse: expecting index...\n");
+
+    r = ser_ntok(&job, &tok, &tmp);
+
+    if (r == ser_tok_err)
+      goto cleanup;
+    else if (r != ser_tok_id)
+    {
+      /* We will only accept an index reference at this point. */
+      snprintf(line, SER_MSGLEN, "error: expecting index at byte %ld, got %s",
+	       job.p_byte, ser_token_code(r));
+      job.log_func(line);
+      goto cleanup;
+    }
+
+    /* Store the numeric index; this is the structure we will work on. */
+    id = tmp;
+
+    SER_DPRINT("parse: expecting opening brace or redirection...\n");
+
+    r = ser_ntok(&job, &tok, &tmp);
+
+    if (r == ser_tok_err)
+      goto cleanup;
+    else if (r == ser_tok_open)
+    {
+      /*
+	Make sure the holder list is big enough. Remember that
+	job.allocated doesn't include index 0.
+      */
+      if (id >= job.allocated)
+	ser_job_realloc_holders(&job, id + 1);
+      
+      /* Is it a duplicate? */
+      if (job.holder[id].start != NULL)
+      {
+	snprintf(line, SER_MSGLEN, "error: index %ld already assigned", id);
+	job.log_func(line);
+	return 0;
+      }
+
+      if (r == ser_tok_open)
+      {
+	/* We need to keep this around to preserve type safety for references.*/
+	job.holder[id].type = strdup(type);
+
+	if (ser_is_primitive(type))
+	{
+	  if (ser_read_primitive(&job, id, type) == 0)
+	    goto cleanup;
+	}
+	else
+	{
+	  /* Find the translator for this type. */
+	  tra = ser_find_tra(first_tra, type);
+	  
+	  if (tra == NULL)
+	  {
+	    snprintf(line, SER_MSGLEN, "error: missing translator for \"%s\"", type);
+	    job.log_func(line);
+	    goto cleanup;
+	  }
+	  
+	  if (ser_read_struct(&job, id, tra) == 0)
+	    goto cleanup;
+	}
+      }
+    }
+    else
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: expecting opening brace at byte %ld, got %s",
+	       job.p_byte, ser_token_code(r));
+      job.log_func(line);
+      goto cleanup;
+    }
+
+    continue;
+  } while (r != ser_tok_err);
+
+count_stuff:
+
+  if (strcmp(expected_type, job.holder[1].type))
+  {
+    /*
+      The data read for #1 doesn't match the type we're
+      expecting. first is already NULL. Abort.
+    */
+    snprintf(line, SER_MSGLEN,
+	     "error: %s #1 does not match expected type %s",
+	     job.holder[1].type, expected_type);
+    job.log_func(line);
+    
+    goto cleanup;
+  }
+
+  if (ser_restore_pointers(&job) == false)
+    goto cleanup;
+
+  first = job.holder[1].start;
+
+cleanup:
+
+  ser_del_subst_ptrs(&job);
+
+  if (job.allocated)
+  {
+    size_t i;
+
+    for (i = 1; i < job.allocated; i++)
+      free(job.holder[i].type);
+  }
+
+  free(job.holder);
+
+  free(job.p_str);
+  
+  return first;
+}
+
+
+
+/**
+   Reads a primitive @type from @job@s parse buffer. The result will be
+   stored in holder @id@ after allocating sufficient memory to stort
+   the type.
+
+   Returns true on success, false on failure.
+
+   #category Internal
+*/
+bool ser_read_primitive(ser_job_t * job, const long id, const char * type)
+{
+  ser_holder_t * holder;
+
+  SER_DPRINT("ser_read_primitive\n");
+
+  if (!job || !id || !type)
+    return false;
+
+  holder = &job->holder[id];
+
+  if (!holder)
+    return false;
+
+  holder->type = strdup(type);
+
+  /*
+    This doesn't get a job; it shouldn't need one since we're after a
+    primitive type.
+  */
+  holder->start = malloc(ser_field_size(NULL, type, 0));
+
+  if (!holder->start || !holder->type)
+    return false;
+
+  ser_tok_t r;
+  char * value;
+  long tmp;
+
+  r = ser_ntok(job, &value, &tmp);
+
+  if (ser_read_value(job, type, r, holder->start, value, tmp) == 0)
+    return false;
+
+  return ser_expect(job, ser_tok_close);
+}
+
+
+
+/**
+   Returns a pointer to the start of field @tag (array offset @ai@) in
+   the structure held by holder index @hi@ in @job@. Returns NULL if
+   it cannot be found.
+
+   If @type is provided the pointer at that location will be pointed
+   to a string with the type of the destination. This is in use
+   somewhere else in the program and should not be freed.
+
+   If @ref is provided it will be set to true if the resolved address
+   points to a reference field or false if it is a normal value or the
+   beginning of a struct (possibly anonymous).
+
+   #category Internal
+*/
+void * ser_resolve_subst_ptr(ser_job_t * job, const size_t hi,
+			     const char * tag, const size_t ai,
+			     char ** type, bool * ref)
+{
+  void * ret;
+  ser_holder_t * holder;
+  ser_field_t * field;
+  
+  if (type)
+    *type = NULL;
+  
+  if (!job)
+    return NULL;
+
+  if (hi > job->allocated)
+    return NULL;
+
+  holder = &job->holder[hi];
+
+  if (!holder)
+    return NULL;
+
+  ret = holder->start;
+
+  if (type)
+    *type = job->holder[hi].type;
+
+  if (ref)
+    *ref = false;
+
+  if (tag)
+  {
+    field = ser_find_field(job->first_tra, holder->type, tag);
+    
+    if (!field)
+      return NULL;
+
+    if (ai >= field->repeat)
+      return NULL;
+
+    ret += field->offset +
+      (ai * ser_field_size(job, field->type, field->ref));
+
+    if (type)
+      *type = field->type;
+
+    if (ref && field->ref)
+      *ref = true;
+  }
+
+  return ret;
+}
+
+
+
+/**
+   Checks that all substitution pointers in @job resolve to valid
+   locations (the holder, field and array index (if >0) must exist).
+
+   #category Internal
+ */
+bool ser_check_subst_ptrs(ser_job_t * job)
+{
+  char line[SER_MSGLEN];
+  ser_subst_ptr_t * sptr;
+  void * new_ptr;
+
+  if (!job)
+    return false;
+
+  SER_DPRINT("ser_subst_ptrs()\n");
+
+  for (sptr = job->first_sptr; sptr != NULL; sptr = sptr->next)
+  {
+    SER_DPRINT("subst ptr: holder[%ld].%s[%ld]\n",
+	       sptr->d_hi,
+	       (sptr->d_tag ? sptr->d_tag : "(base)"),
+	       sptr->d_ai);
+    
+    new_ptr = ser_resolve_subst_ptr(job, sptr->d_hi, sptr->d_tag,
+				    sptr->d_ai, NULL, NULL);
+    
+    if (!new_ptr)
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: bad reference %ld",
+	       sptr->d_hi);
+      job->log_func(line);
+      return false;
+    }
+    
+    SER_DPRINT("-- should replace with %p\n", new_ptr);
+  }
+
+  return true;
+}
+
+
+
+/**
+   Creates a new substitution pointer structure in @job@. When
+   dereferenced, the subst pointer will resolve to
+   holder[@d_hi@].@d_tag@[@d_ai@]. Any pointer that wants to use this
+   location should point themselves at the structure returned.
+
+   #category Internal
+*/
+ser_subst_ptr_t * ser_add_subst_ptr(ser_job_t * job, const size_t d_hi,
+				    const char * d_tag, const size_t d_ai)
+{
+  ser_subst_ptr_t * sptr;
+
+  if (!job)
+    return NULL;
+    
+  sptr = malloc(sizeof(ser_subst_ptr_t));
+
+  if (!sptr)
+    return NULL;
+
+  sptr->d_hi = d_hi;
+  sptr->d_tag = NULL;
+  sptr->d_ai = d_ai;
+
+  if (d_tag)
+  {
+    sptr->d_tag = strdup(d_tag);
+
+    if (!sptr->d_tag)
+    {
+      free(sptr);
+      return NULL;
+    }
+  }
+
+  sptr->next = job->first_sptr;
+  job->first_sptr = sptr;
+
+  return sptr;
+}
+
+
+
+/*
+  Picks @token apart and returns its components. @token might be
+  modified and must therefore be writeable.
+
+  @token should be a reference of the form #holder.field[a] where
+  holder is the numeric index of a holder, field the tag och a field
+  name within that holder and a the array offset for that field. [a]
+  may be omitted, .field may be omitted if no [a] is provided.
+
+  The result will be stored at the locations pointed to by
+  @holder_dest, @field_dest and @index_dest@. If @token contains no
+  field tag, *field_dest will point at NULL. If @token contains no
+  array index *index_dest will be zero. All three destinations must be
+  provided even if no value is expected for them. The string at
+  *field_dest will be a substring of @token and should not be freed
+  separately.
+
+  Returns false on error (token wasn't a reference), true on success;
+  note however that this doesn't say if the reference is valid (holder
+  out of bounds, field tag or array index that doesn't exist), just
+  that the expression could be parsed.
+*/
+bool ser_dissect_reference(char * token, size_t * holder_dest,
+			   char ** field_dest, size_t * index_dest)
+{
+  size_t holder;
+  size_t index;
+  char * dot;
+  char * bracket_start;
+  char * bracket;
+  char * bracket_end;
+  char * read_end;
+  char * token_end;
+
+  if (!token || !holder_dest || !field_dest || !index_dest)
+    return false;
+
+  /* If no array index is found we will assume 0. */
+  index = 0;
+
+  /* Find the end of the token string */
+  token_end = token;
+  while (*token_end)
+    token_end++;
+
+  /* Find an opening bracket. */
+  bracket_start = strchr(token, '[');
+  
+  if (bracket_start)
+  {
+    bracket = bracket_start;
+    *bracket = '\0';
+    bracket++;
+
+    /* Extract the array index. */
+    if (*bracket == '\0')
+      return false;
+
+    index = strtoul(bracket, &bracket_end, 10);
+    
+    /* Malformed number or unterminated bracket? */
+    if (*bracket_end != ']' || bracket_end == bracket)
+      return false;
+  }
+
+  /*
+    Find the dot. A field tag should follow; if there is none we will
+    use the base address of the structure.
+  */
+  dot = strchr(token, '.');
+
+  /* Check for "#." and "#[" */
+  if (dot == (token + 1) || bracket_start == (token + 1))
+    return false;
+
+  /* Extract the holder index. +1 to skip the initial # in the id. */
+  holder = strtoul(token + 1, &read_end, 10);
+
+  /* Make sure the index ends where we expect it to. */
+  if ((dot && read_end != dot) ||
+      (!dot && bracket_start && read_end != bracket_start) ||
+      (!dot && !bracket_start && read_end != token_end))
+    return false;
+
+  /* We got through that ok; set the destination values. */
+
+  if (!dot || dot == token_end)
+    *field_dest = NULL;
+  else
+  {
+    if (*(dot + 1) == '\0')
+      *field_dest = NULL;
+    else
+      *field_dest = dot + 1;
+  }
+  
+  *holder_dest = holder;
+
+  *index_dest = index;
+
+  return true;
+}
+
+
+
+/**
+   Goes through every structure held by @job and resolves reference
+   indices to real pointers.
+
+   For example, any reference to #2 will be replaced by the address in
+   holder[2]->start.
+
+   Returns true on success, false on failure.
+
+   #category Internal
+*/
+bool ser_restore_pointers(ser_job_t * job)
+{
+  ser_holder_t * holder;
+  ser_field_t * field;
+  ser_tra_t * tra;
+  size_t i;
+
+  if (!job)
+    return false;
+
+  SER_DPRINT("job uses %ld holders\n", job->allocated);
+
+  for (i = 1; i < job->allocated; i++)
+  {
+    if (job->holder[i].start == NULL &&
+	(job->holder[i].replace_id == 0 ||
+	 job->holder[i].replace_field == NULL))
+    {
+      SER_DPRINT("warning: holder[%ld] is null and lacks replace id/field", i);
+    }
+  }
+
+  /*
+    Try to convert reference indices to real pointers.  Scan each
+    structure for reference fields, check if their index exists in
+    the holder list.
+  */
+
+  for (i = 1; i < job->allocated; i++)
+  {
+    holder = &job->holder[i];
+
+    if (holder == NULL ||
+	holder->start == NULL)
+    {
+      SER_DPRINT("holder[%ld] is NULL\n", i);
+      continue;
+    }
+
+    if (ser_is_primitive(holder->type))
+    {
+      SER_DPRINT("holder[%ld] is primitive type; nothing to restore\n", i);
+      continue;
+    }
+
+    tra = ser_find_tra(job->first_tra, holder->type);
+    
+    SER_DPRINT("holder[%ld]: %s at %p%s\n",
+	       i, tra->id, (void*)&job->holder[i],
+	       (tra->atype ? " (array)" : ""));
+
+    /*
+      Fill in array count fields. This must be done before restoring
+      pointers in the structure, or otherwise the holder indices (where
+      the element count for dynamic arrays are stored) will already have
+      been replaced with real pointers.
+    */
+    ser_restore_array_counts(job, holder, tra);
+
+    /* Restore pointers */
+    
+    for (field = tra->first_field; field != NULL; field = field->next)
+    {
+      if (field->tag[0] == '@')
+      {
+	SER_DPRINT("field %s %s - array count, already dealt with\n",
+		   field->type, field->tag);
+      }
+      else if (field->ref)
+      {
+	/* Try to restore pointer */
+	SER_DPRINT("holder[%ld]: field %s %s - restoring pointer(s)...\n",
+		   i, field->type, field->tag);
+
+	if (ser_restore_ptr(job, holder, tra, field) == false)
+	  return false;
+      }
+      else if (ser_is_primitive(field->type))
+      {
+	/* Do nothing */
+	SER_DPRINT("field %s %s - native\n",
+		   field->type, field->tag);
+      }
+    }
+  }
+
+  if (ser_check_subst_ptrs(job) == 0)
+    return false;
+  
+  return true;
+}
+
+
+
+/**
+   Resolves the destination holder for a substitution pointer structure
+   located at @field in @holder. @tra should be the translator for
+   @holder@. If @tra or @field is an array all elements will be
+   processed.
+   
+   Returns true on success, false on failure.
+   
+   #category Internal
+*/
+bool ser_restore_ptr(ser_job_t * job, ser_holder_t * holder,
+		     ser_tra_t * tra, ser_field_t * field)
+{
+  char line[SER_MSGLEN];
+
+  ser_subst_ptr_t * sptr;
+  size_t e_size; /* array element size */
+  size_t repeat; /* number of array elements */
+  size_t a_i; /* array index */
+  void * field_base;
+  void * subst_location;
+      
+  if (!job || !holder || !tra || !field)
+    return false;
+
+  e_size = ser_field_size(job, field->type, field->ref);
+  
+  field_base = holder->start + field->offset;
+  
+  /* */
+  if (tra->atype == ser_array_dynamic ||
+      tra->atype == ser_array_nullterm)
+  {
+    repeat = holder->elements;
+    
+    SER_DPRINT("array repeat %ld\n", repeat);
+  }
+  else
+  {
+    repeat = field->repeat;
+    
+    SER_DPRINT("single field or static array at offset %ld (repeat %ld)\n",
+	       field->offset, repeat);
+  }
+  
+  for (a_i = 0; a_i < repeat; a_i++)
+  {
+    subst_location = field_base + (e_size * a_i);
+    
+    sptr = *(ser_subst_ptr_t **)subst_location;
+    
+    /*printf("%ld, %ld\n\n", job->things, sptr->d_hi);
+      printf("%s\n\n", job->holder[sptr->d_hi].type);*/
+
+    if (sptr)
+    {
+      void * dest;
+      char * type;
+      bool ref;
+
+      dest = ser_resolve_subst_ptr(job, sptr->d_hi, sptr->d_tag,
+				   sptr->d_ai, &type, &ref);
+      
+      if (sptr->d_hi >= job->allocated || !dest)
+      {
+	snprintf(line, SER_MSGLEN,
+		 "error: unable to resolve substitution pointer "
+		 "for holder[%ld].%s[%ld]",
+		 sptr->d_hi,
+		 (sptr->d_tag ? sptr->d_tag : ""),
+		 sptr->d_ai);
+	job->log_func(line);
+	return false;
+      }
+
+      if (strcmp(field->type, type) || ref)
+      {
+	/* The holder index is valid but types mismatch. */
+	
+	snprintf(line, SER_MSGLEN,
+		 "error: type mismatch; expecting %s but destination is %s%s",
+		 field->type,
+		 type, (ref ? " reference" : ""));
+	job->log_func(line);
+	return false;
+      }
+      
+      *(void **)(subst_location) = dest;
+    }
+  }
+
+  return true;
+}
+
+
+
+
+/*
+  Fill in array count fields for @holder@ (of type @tra@) in
+  @job@. This will search for fields prefixed with @@ and a matching
+  array pointer without the @@. The count field will be set to
+*/
+bool ser_restore_array_counts(ser_job_t * job, ser_holder_t * holder, ser_tra_t * tra)
+{
+  ser_subst_ptr_t * sptr;
+  ser_holder_t * subst_holder;
+  ser_field_t * field;
+  ser_field_t * array_field;
+  size_t array_target;
+  char * array_name;
+  void * thing;
+  
+  if (!job || !holder || !tra)
+    return false;
+
+  thing = holder->start;
+
+  for (field = tra->first_field; field != NULL; field = field->next)
+  {
+    if (field->tag[0] != '@')
+      continue;
+
+    /*
+      This is an array count. It should be set to the "elements"
+      count of corresponding destination holder.
+    */
+    
+    /* RFE: Check if it is a numeric type */
+
+    SER_DPRINT("field %s %s - array length\n", field->type, field->tag);
+    
+    /* It's linked to the reference with the same name, without the @ */
+    array_name = &field->tag[1];
+    array_field = ser_find_field(tra, tra->id, array_name);
+    
+    if (!array_field)
+    {
+      SER_DPRINT("warning: couldn't determine array field\n");
+      continue;
+    }
+
+    /* */
+    sptr = *(ser_subst_ptr_t **)(thing + array_field->offset);
+    
+    array_target = sptr->d_hi;
+    
+    SER_DPRINT("%s %s seems to be holder %ld\n",
+	       array_field->type, array_field->tag, array_target);
+    
+    if (array_target > job->allocated)
+    {
+      SER_DPRINT("warning: invalid holder index %ld\n", array_target);
+      continue;
+    }
+
+    subst_holder = &job->holder[array_target];
+    
+    if (ser_is_signed(field->type))
+      ser_write_signed(thing + field->offset, field->type, subst_holder->elements);
+    else
+      ser_write_unsigned(thing + field->offset, field->type, subst_holder->elements);
+    
+    SER_DPRINT("%s %s seems to be be %ld elements\n",
+	       array_field->type, array_field->tag, subst_holder->elements);
+  }
+
+  return true;
+}
+
+
+
+/*
+   #category Internal
+*/
+void ser_write_unsigned(void * ptr, const char * type, const unsigned long uvalue)
+{
+  if (strcmp(type, "ushort") == 0)
+    *(unsigned short *)ptr = uvalue;
+  else if (strcmp(type, "uint") == 0)
+    *(unsigned int *)ptr = uvalue;
+  else if (strcmp(type, "ulong") == 0)
+    *(unsigned long *)ptr = uvalue;
+  else if (strcmp(type, "size_t") == 0)
+    *(size_t *)ptr = uvalue;
+  else if (strcmp(type, "uint8_t") == 0)
+    *(uint8_t *)ptr = uvalue;
+  else if (strcmp(type, "uint16_t") == 0)
+    *(uint16_t *)ptr = uvalue;
+  else if (strcmp(type, "uint32_t") == 0)
+    *(uint32_t *)ptr = uvalue;
+
+  return;
+}
+
+
+
+/*
+   #category Internal
+*/
+void ser_write_signed(void * ptr, const char * type, const signed long svalue)
+{
+  if (strcmp(type, "short") == 0)
+    *(short *)ptr = svalue;
+  else if (strcmp(type, "int") == 0)
+    *(int *)ptr = svalue;
+  else if (strcmp(type, "long") == 0)
+    *(long *)ptr = svalue;
+  else if (strcmp(type, "int8_t") == 0)
+    *(int8_t *)ptr = svalue;
+  else if (strcmp(type, "int16_t") == 0)
+    *(int16_t *)ptr = svalue;
+  else if (strcmp(type, "int32_t") == 0)
+    *(int32_t *)ptr = svalue;
+  else if (strcmp(type, "time_t") == 0)
+    *(time_t *)ptr = svalue;
+
+  return;
+}
+
+
+
+/**
+   Checks if @type is a signed numeric type.
+
+   #category Types
+*/
+bool ser_is_signed(const char * type)
+{
+  if (strcmp(type, "short") == 0 ||
+      strcmp(type, "int") == 0 ||
+      strcmp(type, "long") == 0 ||
+      strcmp(type, "int8_t") == 0 ||
+      strcmp(type, "int16_t") == 0 ||
+      strcmp(type, "int32_t") == 0 ||
+      strcmp(type, "time_t") == 0)
+  {
+    return true;
+  }
+
+  return false;
+}
+
+
+
+/**
+   Returns a pointer to field @tag in the structure held by holder
+   @holder_index in @job@; NULL if no such field could be found (it's
+   missing in the @id translator) or any other error occurs.
+
+   #category Internal
+*/
+void * ser_replace_ptr(ser_job_t * job,
+		       const size_t holder_index,
+		       const char * tag)
+{
+  char tmp[SER_MSGLEN];
+  ser_tra_t * tra;
+  ser_field_t * field;
+
+  if (!job || !holder_index || !tag)
+    return NULL;
+
+  if (holder_index > job->allocated ||
+      job->holder[holder_index].start == NULL)
+  {
+    snprintf(tmp, SER_MSGLEN,
+	     "error: invalid redirect to holder %ld (it's NULL)", holder_index);
+    job->log_func(tmp);
+    return NULL;
+  }
+
+  tra = ser_find_tra(job->first_tra, job->holder[holder_index].type);
+  
+  if (!tra)
+  {
+    snprintf(tmp, SER_MSGLEN,
+	     "error: lacking translator for holder %ld", holder_index);
+    job->log_func(tmp);
+    return NULL;
+  }
+
+  field = ser_find_field(tra, tra->id, tag);
+
+  if (!field)
+  {
+    snprintf(tmp, SER_MSGLEN,
+	     "error: redirecting to #%ld but %s doesn't have any field %s",
+	     holder_index, tra->id, tag);
+    job->log_func(tmp);
+    return NULL;
+  }
+
+  return (job->holder[holder_index].start + field->offset);
+}
+
+
+
+/*
+   #category Internal
+*/
+void ser_del_subst_ptrs(ser_job_t * job)
+{
+  ser_subst_ptr_t * sptr;
+  ser_subst_ptr_t * next;
+
+  if (!job)
+    return;
+
+  sptr = job->first_sptr;
+
+  while (sptr)
+  {
+    next = sptr->next;
+
+    if (sptr->d_tag)
+      free(sptr->d_tag);
+
+    free(sptr);
+
+    sptr = next;
+  }
+
+  job->first_sptr = NULL;
+  
+  return;
+}
+
+
+
+/**
+   Returns the size (in bytes) of @type@. If @ref is nonzero it will
+   instead return the size of a pointer to such an array (which really
+   will be sizeof(void*)).
+
+   #category Types
+*/
+size_t ser_field_size(ser_job_t * job, const char * type, const int ref)
+{
+  if (!type)
+    return 0;
+
+  if (ref)
+    return sizeof(void *);
+  
+  SER_IF_SIZEOF(int)
+  else SER_IF_SIZEOF(short)
+  else SER_IF_SIZEOF(char)
+  else SER_IF_SIZEOF(long)
+  else SER_IF_SIZEOF(float)
+  else SER_IF_SIZEOF(double)
+  else SER_IF_SIZEOF(long long)
+  else SER_IF_SIZEOF(size_t)
+  else SER_IF_SIZEOF(intptr_t)
+  else SER_IF_SIZEOF(uint8_t)
+  else SER_IF_SIZEOF(uint16_t)
+  else SER_IF_SIZEOF(uint32_t)
+  else SER_IF_SIZEOF(int8_t)
+  else SER_IF_SIZEOF(int16_t)
+  else SER_IF_SIZEOF(int32_t)
+  else if (strcmp(type, "string") == 0)
+    return sizeof(char *);
+  else if (strcmp(type, "ushort") == 0)
+    return sizeof(unsigned short);
+  else if (strcmp(type, "uint") == 0)
+    return sizeof(unsigned int);
+  else if (strcmp(type, "ulong") == 0)
+    return sizeof(unsigned long);
+  
+  if (job)
+  {
+    ser_tra_t * tra;
+    tra = ser_find_tra(job->first_tra, type);
+    
+    if (tra)
+      return tra->size;
+  }
+
+  return 0;
+}
+
+
+
+/**
+   Reads a structure from @job@s input buffer and assigns it to holder
+   @id@. The structure will be parsed according to @thing_tra@.
+
+   Returns true on success, false on error.
+
+   #category Internal
+*/
+bool ser_read_struct(ser_job_t * job, const long id, ser_tra_t * thing_tra)
+{
+  ser_holder_t * holder;
+
+  if (!job || !thing_tra)
+    return false;
+
+  SER_DPRINT("read_struct: in %s #%ld\n", thing_tra->id, id);
+
+  /* This is the holder we will load the struct into. */
+  holder = &job->holder[id];
+
+  /*
+    Prepare memory to load the inflated struct. Find out how much the
+    translator wants. If it is supposed to be a dynamic array, we will
+    be able to reallocate it later.
+  */
+  holder->type = strdup(thing_tra->id);
+
+  holder->start = ser_blank_struct(thing_tra);
+
+  SER_DPRINT("read_struct: allocating %ld bytes for %s in holder %ld, ->start %p\n",
+	     thing_tra->size, thing_tra->id, id, holder->start);
+
+  if (holder->start == NULL)
+  {
+    job->log_func("error: out of memory");
+    return false;
+  }
+
+  /*
+    If this is a dynamic array type we pass the holder along. If it's
+    a "flat" structure we won't allow reallocation.
+  */
+  if (thing_tra->atype == ser_flat)
+    return ser_read_struct_internal(job, NULL, thing_tra, holder->start);
+  else
+    return ser_read_struct_internal(job, holder, thing_tra, holder->start);
+}
+
+
+
+/**
+   Assumes @job@s input parsing is at the start of a structure (after
+   the opening brace). Reads the structure into @ptr according to
+   @thing_tra@. If @holder is non-NULL, it will be used to reallocate
+   ptr (if needed; this is only used for dynamic arrays - do not pass
+   it when reading static arrays or embedded structs).
+
+   Returns true on success, false on error.
+
+   #category Internal
+*/
+bool ser_read_struct_internal(ser_job_t * job, ser_holder_t * holder,
+			      ser_tra_t * thing_tra, void * ptr)
+{
+  char line[SER_MSGLEN];
+  char * tag;
+  char * value;
+  void * dest;
+  ser_field_t * field;
+  ser_tok_t r;
+  long tmp;
+  size_t repeat;
+  size_t i;
+
+  if (!job || !thing_tra || !ptr)
+    return false;
+
+  if (holder)
+  {
+    SER_DPRINT("ser_read_struct_internal: dynamic structure (holder != NULL)\n");
+  }
+  else
+  {
+    SER_DPRINT("ser_read_struct_internal: flat structure (holder == NULL)\n");
+  }
+
+  /*
+    Read field identifiers + values for the structure. Do this until
+    we receive a closing brace.
+  */
+  while (1)
+  {
+    if (thing_tra->atype == ser_flat)
+    {
+      SER_DPRINT("normal type: expecting field tag or closing brace...\n");
+
+      r = ser_ntok(job, &tag, &tmp);
+
+      if (r == ser_tok_close)
+      {
+	/*
+	  RFE: This would be a good place to verify that all values
+	  have been read for a structure, but we don't have such an option yet.
+	*/
+
+	SER_DPRINT("got closing brace; finishing structure\n");
+	break;
+      }
+      else if (r != ser_tok_any)
+      {
+	/* These are error conditions. */
+	if (r == ser_tok_end)
+	{
+	  snprintf(line, SER_MSGLEN,
+		   "error: premature end of structure at byte %ld",
+		   job->p_byte);
+	  job->log_func(line);
+	}
+	else if (r != ser_tok_err)
+	{
+	  snprintf(line, SER_MSGLEN,
+		   "error: unexpected token at byte %ld", job->p_byte);
+	  job->log_func(line);
+	}
+	
+	/*
+	  ser_tok_err tokens should already have printed their own
+	  message in ser_ntok, so we will skip them.
+	*/
+
+	return false;
+      }
+
+      /*
+	Let's assume it was a tag we received. Find out if it exists
+	in the current translator.
+      */
+      
+      field = ser_find_field(thing_tra, thing_tra->id, tag);
+      
+      if (field == NULL)
+      {
+	snprintf(line, SER_MSGLEN,
+		 "error: unknown field %s:%s at byte %ld",
+		 thing_tra->id, tag, job->p_byte);
+	job->log_func(line);
+	return false;
+      }
+    }
+    else if (thing_tra->atype == ser_array_dynamic ||
+	     thing_tra->atype == ser_array_nullterm)
+    {
+      /*
+	If the translator is a dynamic array we will only use the first
+	field. We will _not_ expect a field tag in the input.
+      */
+
+      field = thing_tra->first_field;
+
+      SER_DPRINT("%s is array type: using first field %s %s\n",
+		 thing_tra->id, field->type, field->tag);
+    }
+
+    repeat = field->repeat;
+
+    SER_DPRINT("field %s is %s%s (size %ld) at offset %ld, repeat %ld\n",
+	       field->tag, field->type,
+	       (field->ref ? " reference" : ""),
+	       ser_field_size(job, field->type, field->ref),
+	       field->offset, field->repeat);
+    
+    /* If we're expecting an array, we want an opening & closing brace */
+    if (thing_tra->atype == ser_flat && field->repeat != 1)
+    {
+      if (ser_expect(job, ser_tok_open) == 0)
+	return false;
+    }
+
+    /*
+      If this is a dynamic array, we don't want any limit on how many
+      elements we can read.
+    */
+    if (thing_tra->atype == ser_array_dynamic ||
+	thing_tra->atype == ser_array_nullterm)
+      repeat = UINTPTR_MAX;
+
+    /* The field exists, we know what type to expect for value. */
+    
+    for (i = 0; i < repeat; i++)
+    {
+      dest =
+	ptr + field->offset +
+	ser_field_size(job, field->type, field->ref) * i;
+
+      if (holder)
+      {
+	SER_DPRINT("holder %p, start %p, destination for value: %p\n",
+		   holder, holder->start, dest);
+      }
+
+      /*      
+	      if (strcmp(thing_tra->id, "creature_array") == 0)
+	      {
+	      SER_DPRINT("this is it\n");
+	      }
+      */
+
+      r = ser_ntok(job, &value, &tmp);
+	  
+      if (r == ser_tok_err)
+      {
+	/* Errors should already have been reported in ser_ntok */
+	return false;
+      }
+      else if (r == ser_tok_id)
+      {
+	if (!field->ref && strcmp(field->type, "string"))
+	{
+	  snprintf(line, SER_MSGLEN,
+		   "error: got reference but field %s isn't a reference type at byte %ld",
+		   field->tag, job->p_byte);
+	  job->log_func(line);
+	  return false;
+	}
+
+	/* Reference to other structure */
+	SER_DPRINT("field %s is \"%s\" reference\n", field->tag, value);
+	
+	if (strcasecmp(value, "NULL") == 0)
+	{
+	  *(void **)dest = NULL;
+
+	  SER_DPRINT("-- NULL\n");
+	}
+	else
+	{
+	  size_t d_hi;
+	  char * d_tag;
+	  size_t d_ai;
+	  ser_subst_ptr_t * sptr;
+	  
+	  if (ser_dissect_reference(value, &d_hi, &d_tag, &d_ai) == 0)
+	  {
+	    snprintf(line, SER_MSGLEN,
+		     "error: bad reference at byte %ld", job->p_byte);
+	    job->log_func(line);
+	    return false;
+	  }
+	  
+	  sptr = ser_add_subst_ptr(job, d_hi, d_tag, d_ai);
+	  
+	  if (!sptr)
+	  {
+	    snprintf(line, SER_MSGLEN,
+		     "error: couldn't create subst ptr for holder %ld", d_hi);
+	    job->log_func(line);
+	    return false;
+	  }
+	
+	  *(void**)dest = sptr;
+
+	  SER_DPRINT("-- subst ptr to %ld.%s[%ld]\n",
+		     sptr->d_hi, sptr->d_tag, sptr->d_ai);
+	}
+      }
+      else if (ser_read_value(job, field->type, r, dest, value, tmp) == 0)
+      {
+	return false;
+      }
+
+      if (holder && thing_tra->atype != ser_flat)
+      {
+	/* Update how many elements we have read */
+	holder->elements++;
+      }
+
+      if (repeat > 1 && i == repeat - 1)
+      {
+	/* This is a fixed-size array. */
+	SER_DPRINT("expecting closing brace...\n");
+
+	if (ser_expect(job, ser_tok_close) == 0)
+	  return false;
+
+	/*
+	  It's a static array. Check that we got the number of
+	  elements we wanted. Set repeat to 1 so we won't expect
+	  another closing brace.
+	*/
+	
+	if (i < repeat - 1)
+	{
+	  snprintf(line, SER_MSGLEN,
+		   "warning: too few values received for %s:%s",
+		   thing_tra->id, field->tag);
+	  job->log_func(line);
+	}
+      }
+      else if (i < repeat - 1)
+      {
+	/* This only happens for repeat > 0 */
+
+	SER_DPRINT("expecting separator or closing brace...\n");
+
+	r = ser_ntok(job, &value, &tmp);
+
+	if (r == ser_tok_err)
+	  return false;
+	else if (r == ser_tok_close)
+	{
+	  /*
+	    Dynamic arrays don't need any closing brace for the
+	    __internal__ field; one is enough to close the whole
+	    structure.
+	  */
+
+	  if (thing_tra->atype == ser_array_dynamic ||
+	      thing_tra->atype == ser_array_nullterm)
+	  {
+	    return true;
+	  }
+
+	  break;
+	}
+	else if (r != ser_tok_sep)
+	{
+	  snprintf(line, SER_MSGLEN,
+		   "error: expecting separator, got %s at byte %ld",
+		   ser_token_code(r), job->p_byte);
+	  job->log_func(line);
+	  return false;
+	}
+	else
+	{
+	  /* Got a separator */
+
+	  if (holder)
+	  {
+	    size_t nsize;
+	    nsize = thing_tra->size * (holder->elements + 1);
+
+	    SER_DPRINT("reallocating %ld elements\n", holder->elements + 1);
+	    SER_DPRINT("field size for %s: %ld\n", thing_tra->id, thing_tra->size);
+	    SER_DPRINT("total %ld bytes\n", nsize);
+	    
+	    ptr = realloc(holder->start, nsize);
+
+	    if (!ptr)
+	    {
+	      free(holder->start);
+	      job->log_func("out of memory");
+	      return false;
+	    }
+
+	    holder->start = ptr;
+	  }
+	  else if (repeat == 1)
+	  {
+	    snprintf(line, SER_MSGLEN,
+		     "error: got %s at byte %ld, but not expecting array",
+		     ser_token_code(r), job->p_byte);
+	    job->log_func(line);
+	    return false;
+	  }
+	}
+      }
+    } /* for repeat */
+
+    /*
+      For flat structures we want terminators after each value.
+    */
+    if (thing_tra->atype == ser_flat)
+    {
+      if (ser_expect(job, ser_tok_term) == 0)
+	return false;
+    }
+  } /* while r */
+
+  return true;
+}
+
+
+
+/**
+   Reads a token from @job@s input buffer. Returns true if it is of
+   type @expected@, otherwise false. If it is of another type a
+   message will be sent to @job@s log_func. The output will be
+   discarded (this is mostly useful for detecting braces and
+   terminators).
+
+   #category Internal
+*/
+bool ser_expect(ser_job_t * job, ser_tok_t expected)
+{
+  char line[SER_MSGLEN];
+  ser_tok_t r;
+  char * value;
+  long tmp;
+
+  if (!job)
+    return false;
+
+  SER_DPRINT("expecting %s\n", ser_token_code(expected));
+  
+  r = ser_ntok(job, &value, &tmp);
+  
+  if (r == ser_tok_err)
+  {
+    /* Error message already printed in ser_ntok */
+    return false;
+  }
+  else if (r != expected)
+  {
+    snprintf(line, SER_MSGLEN,
+	     "error: expecting %s, got %s at byte %ld",
+	     ser_token_code(expected),
+	     ser_token_code(r),
+	     job->p_byte);
+    job->log_func(line);
+    return false;
+  }
+
+  return true;
+}
+
+
+
+/**
+   Reads @token into @where. @r is the type of token provided and must
+   match the @field. If the field is a numeric @value will be used
+   instead of @token.
+
+   Returns true on success, false on failure.
+
+   #category Internal
+*/
+bool ser_read_value(ser_job_t * job, const char * type, ser_tok_t r,
+		    void * where, char * token, long int value)
+{
+  char line[SER_MSGLEN];
+
+  if (!job || /*!field ||*/ !where || !token)
+    return false;
+
+  SER_DPRINT("ser_read_value()\n");
+
+  if (strcmp(type, "string") == 0)
+  {
+    if (r == ser_tok_any && strcmp(token, "NULL") == 0)
+    {
+      SER_DPRINT("field is NULL - OK!\n");
+      *(char **)where = NULL;
+    }
+    else
+    {
+      if (r != ser_tok_string)
+      {
+	snprintf(line, SER_MSGLEN,
+		 "error: expecting %s, got %s at byte %ld",
+		 type, ser_token_code(r), job->p_byte);
+	job->log_func(line);
+	return false;
+      }
+      
+      char * dup_value;
+      
+      dup_value = ser_unescape_str(token);
+      
+      if (!dup_value)
+      {
+	job->log_func("error: out of memory");
+	return false;
+      }
+      
+      /* Success! */
+      *(char **)where = dup_value;
+      
+      SER_DPRINT("field is \"%s\" - OK!\n", dup_value);
+    }
+  }
+  else if (strcmp(type, "float") == 0 ||
+	   strcmp(type, "double") == 0 ||
+	   strcmp(type, "ldouble") == 0)
+  {
+    long double num;
+    char * endptr;
+
+    num = strtold(token, &endptr);
+
+    if (*endptr != '\0')
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: expecting %s, got %s at byte %ld",
+	       type, ser_token_code(r), job->p_byte);
+      job->log_func(line);
+      return false;
+    }
+
+    if (strcmp(type, "float") == 0)
+      *(float*)where = num;
+    else if (strcmp(type, "double") == 0)
+      *(double*)where = num;
+    else if (strcmp(type, "ldouble") == 0)
+      *(long double*)where = num;
+  }
+  else if (strcmp(type, "bool") == 0)
+  {
+    if (value)
+      *(bool*)where = true;
+    else
+      *(bool*)where = false;
+  }
+  else if (strcmp(type, "ushort") == 0 ||
+	   strcmp(type, "short") == 0 ||
+	   strcmp(type, "uint") == 0 ||
+	   strcmp(type, "int") == 0 ||
+	   strcmp(type, "ulong") == 0 ||
+	   strcmp(type, "long") == 0 ||
+	   strcmp(type, "time_t") == 0 ||
+	   strcmp(type, "size_t") == 0 ||
+	   strcmp(type, "uint8_t") == 0 ||
+	   strcmp(type, "uint16_t") == 0 ||
+	   strcmp(type, "uint32_t") == 0 ||
+	   strcmp(type, "int8_t") == 0 ||
+	   strcmp(type, "int16_t") == 0 ||
+	   strcmp(type, "int32_t") == 0)
+  {
+    signed long svalue;
+    unsigned long uvalue;
+    int sign;
+    char * endptr;
+
+    if (ser_is_signed(type))
+    {
+      svalue = strtol(token, &endptr, 10);
+      sign = 1;
+    }
+    else
+    {
+      uvalue = strtoul(token, &endptr, 10);
+      sign = 0;
+    }
+    
+    if (*endptr != '\0')
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: expecting %s, got %s at byte %ld",
+	       type, ser_token_code(r), job->p_byte);
+      job->log_func(line);
+      return false;
+    }
+
+    if (sign)
+      ser_write_signed(where, type, svalue);
+    else
+      ser_write_unsigned(where, type, uvalue);
+
+    SER_DPRINT("field is %ld - OK!\n", value);
+  }
+  else if (strcmp(type, "char") == 0)
+  {
+    if (r != ser_tok_char)
+    {
+      sprintf(line, "error: expecting %s, got %s at byte %ld",
+	      type, ser_token_code(r), job->p_byte);
+      job->log_func(line);
+      return false;
+    }
+    
+    SER_DPRINT("field is %c - OK!\n", (char)value);
+
+    *(char *)where = (char)value;
+  }
+  else if (r == ser_tok_open)
+  {
+    SER_DPRINT("read_value: got opening brace; anonymous struct\n");
+
+    ser_tra_t * anon_tra;
+    anon_tra = ser_find_tra(job->first_tra, type);
+
+    if (anon_tra)
+    {
+      if (ser_read_struct_internal(job, NULL, anon_tra, where) == 0)
+	return false;
+    }
+    else
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: no translator for anonymous %s at byte %ld",
+	       type, job->p_byte);
+      job->log_func(line);
+      return false;
+    }
+  }
+  else if (r != ser_tok_any && r != ser_tok_id)
+  {
+    snprintf(line, SER_MSGLEN,
+	     "error: expecting field value, got %s at byte %ld",
+	     ser_token_code(r), job->p_byte);
+    job->log_func(line);
+    return false;
+  }
+  
+  return true;
+}
+
+
+
+/**
+   Extracts a new token from @job@s parse buffer. Returns the type of
+   token, ser_tok_any if it can't determine what it is. @dest will be
+   repointed to the string representation of the token. @value will be
+   set to the numerical value, if it can be determined.
+   
+   On error, ser_tok_err is returned and a message will be printed
+   using the log_func of @job. In these cases, it is usually not
+   necessary to print any other error messages.
+
+   #category Internal
+*/
+ser_tok_t ser_ntok(ser_job_t * job, char ** dest, long int * value)
+{
+  char line[SER_MSGLEN];
+
+  ptrdiff_t comment_start;
+
+  char * start;
+  char * end;
+
+  if (!job || !dest || !value)
+    return ser_tok_err;
+
+  start = job->p_pos;
+
+strip_whitespace:
+  while (*start == ' ' || *start == '\n' || *start == '\t')
+  {
+    start++;
+  }
+
+  job->p_byte = start - job->p_str;
+
+  if (*start == '\0')
+    return ser_tok_end;
+  
+  /* Bypass comments */
+  if (*start == '/' && *(start+1) == '*')
+  {
+    comment_start = start - job->p_str;
+
+    start += 2;
+
+    while (1)
+    {
+      if (*start == '\0')
+      {
+	snprintf(line, SER_MSGLEN,
+		 "error: unterminated comment starting at byte %ld",
+		 comment_start);
+	job->log_func(line);
+	return ser_tok_err;
+      }
+      else if (*start == '*' && *(start+1) == '/')
+      {
+	start += 2;
+	goto strip_whitespace;
+      }
+      else
+      {  
+	start++;
+      }
+    }
+  }
+
+  if (*start == '\0')
+    return ser_tok_end;
+  
+  end = start;
+    
+  if (*start == ';' || *start == ',')
+  {
+  }
+  else if (*start == '\"')
+  {
+    do
+    {
+      if (*end == '\\')
+      {
+	end++;
+
+	if (*end == '\\' || *end == '\"')
+	  end++;
+      }
+      else
+	end++;
+    } while (*end != '\"' && *end != '\0');
+
+    if (*end == '\0')
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: premature end of string at byte %ld",
+	       job->p_byte);
+      job->log_func(line);
+      return ser_tok_err;
+    }
+
+    *end = '\0';
+  }
+  else if (*start == '\'')
+  {
+    end++;
+
+    while (*end != '\'')
+    {
+      if (*end == '\0')
+      {
+	snprintf(line, SER_MSGLEN,
+		 "error: broken character at byte %ld",
+		 job->p_byte);
+	job->log_func(line);
+	return ser_tok_err;
+      }
+
+      end++;
+    }
+
+    /* Found the ' */
+    end++;
+    *end = '\0';
+  }
+  else
+  {
+    while (*end != ' ' && *end != '\n' &&
+	   *end != '\t' && *end != '\0' &&
+	   *end != ';')
+    {
+      end++;
+    }
+
+    *end = '\0';
+  }
+
+  job->p_pos = end + 1;
+  
+  *dest = start;
+
+  job->p_byte = start - job->p_str;
+
+  if (*start == ';' || *start == ',')
+  {
+    SER_DPRINT("@ %ld >%c<\n", start - job->p_str, *start);
+
+    if (*start == ';')
+      return ser_tok_term;
+    else if (*start == ',')
+      return ser_tok_sep;
+  }
+
+  SER_DPRINT("@ %ld >%s<\n", start - job->p_str, start);
+
+  if (*start == '\"')
+  {
+    /*
+      This is a string token. The endpoint should already have reached
+      the terminating quote and replaced it with a null byte, so we
+      only need to move the start past the opening quote.
+    */
+
+    start++;
+    (*dest)++;
+
+    return ser_tok_string;
+  }
+  else if (*start == '\'')
+  {
+    SER_DPRINT("char %s, %c %c %c\n",
+	       start, *(start + 1), *(start + 2), *(start + 3));
+
+    /* It's a character. Is it backslash-escaped hex? */
+
+    if (*(start + 1) == '\\' && *(start + 2) == 'x')
+    {
+      *value = ser_hex2char(start + 3);
+
+      SER_DPRINT("escaped %ld\n", *value);
+
+      return ser_tok_char;
+    }
+
+    *value = *(start + 1);
+    return ser_tok_char;
+  }
+  else if (*start == '#')
+  {
+    /*
+      It's a reference to another serialized structure.
+      Try to extract the integer value.
+    */
+
+    char * endptr;
+
+    *value = strtol(start + 1, &endptr, 10);
+
+    if (endptr == start + 1)
+    {
+      snprintf(line, SER_MSGLEN,
+	       "error: bad reference at byte %ld: %s", end - job->p_str, start);
+      job->log_func(line);
+      return ser_tok_err;
+    }
+
+    return ser_tok_id;
+  }
+  else if (*start == '{')
+    return ser_tok_open;
+  else if (*start == '}')
+    return ser_tok_close;
+  else if (strcasecmp(start, "true") == 0)
+  {
+    *value = true;
+    return ser_tok_int;
+  }
+  else if (strcasecmp(start, "false") == 0)
+  {
+    *value = false;
+    return ser_tok_int;
+  }
+  else if (strcasecmp(start, "NULL") == 0)
+  {
+    *value = 0;
+    return ser_tok_id;
+  }
+
+  char * endptr;
+  
+  *value = strtol(start, &endptr, 10);
+  
+  if (endptr == end)
+    return ser_tok_int;
+
+  return ser_tok_any;
+}
+
+
+
+/**
+   Returns if @s is a type that can be serialized natively (without a
+   user-provided translator).
+
+   #category Types
+*/
+bool ser_is_primitive(const char * s)
+{
+  if (!s)
+    return false;
+
+  if (strcmp(s, "string") == 0 ||
+      strcmp(s, "bool") == 0 ||
+      strcmp(s, "char") == 0 ||
+      strcmp(s, "short") == 0 ||
+      strcmp(s, "ushort") == 0 ||
+      strcmp(s, "int") == 0 ||
+      strcmp(s, "uint") == 0 ||
+      strcmp(s, "long") == 0 ||
+      strcmp(s, "ulong") == 0 ||
+      strcmp(s, "size_t") == 0 ||
+      strcmp(s, "time_t") == 0 ||
+      strcmp(s, "intptr_t") == 0 ||
+      strcmp(s, "uint8_t") == 0 ||
+      strcmp(s, "uint16_t") == 0 ||
+      strcmp(s, "uint32_t") == 0 ||
+      strcmp(s, "int8_t") == 0 ||
+      strcmp(s, "int16_t") == 0 ||
+      strcmp(s, "int32_t") == 0 ||
+      strcmp(s, "float") == 0 ||
+      strcmp(s, "double") == 0 ||
+      strcmp(s, "ldouble") == 0)
+  {
+    return true;
+  }
+
+  return false;
+}
+
+
+
+/**
+   Given the linked list of translators @tra, finds the one called @id@.
+
+   #category Translators
+*/
+ser_tra_t * ser_find_tra(ser_tra_t * tra, const char * id)
+{
+  while (tra)
+  {
+    if (strcmp(tra->id, id) == 0)
+      return tra;
+    
+    tra = tra->next;
+  }
+
+  return NULL;
+}
+
+
+
+/**
+   Returns if @s is a valid type (primitive or present as a translator
+   in translator list @tra@).
+
+   #category Types
+*/
+bool ser_valid_type(ser_tra_t * tra, char * s)
+{
+  if (!s)
+    return false;
+
+  if (ser_is_primitive(s))
+    return true;
+
+  if (!tra)
+    return false;
+
+  if (ser_find_tra(tra, s))
+    return true;
+
+  return false;
+}
+
+
+
+/**
+   Given the translator list @tra@, looks up field @tag in translator @id@.
+
+   Returns a pointer to the field or NULL if it could not be
+   found. Both translator @id and field @tag must match; if there is
+   another translator with the same field tag it will not be detected.
+
+   #category Fields
+*/
+ser_field_t * ser_find_field(ser_tra_t * tra, const char * id, const  char * tag)
+{
+  ser_field_t * f;
+
+  if (!tra || !id || !tag)
+    return NULL;
+
+  while (tra)
+  {
+    if (strcmp(tra->id, id) == 0)
+    {
+      for (f = tra->first_field; f != NULL; f = f->next)
+      {
+	if (strcmp(f->tag, tag) == 0)
+	{
+	  return f;
+	}
+      }
+    }
+    
+    tra = tra->next;
+  }
+
+  return NULL;
+}
+
+
+
+
+/**
+   Returns the field in @tra with offset @offset@, or NULL if none is found.
+
+   #category Internal
+*/
+ser_field_t * ser_field_by_offset(ser_tra_t * tra, const size_t offset)
+{
+  ser_field_t * f;
+
+  if (!tra)
+    return NULL;
+
+  for (f = tra->first_field; f != NULL; f = f->next)
+  {
+    if (f->offset == offset)
+    {
+      return f;
+    }
+  }
+    
+  return NULL;
+}
+
+
+
+
+/**
+   Allocates and blanks memory for a structure of type @tra@.
+
+   #category Internal
+*/
+void * ser_blank_struct(ser_tra_t * tra)
+{
+  void * ret;
+
+  if (!tra)
+    return NULL;
+
+  ret = calloc(1, tra->size);
+
+  return ret;
+}
+
+
+
+/**
+   Creates a copy of @s with quotes, backslashes and non-printable
+   characters preceded by backslashes. Newline characters (ASCII 10)
+   will be represented as \n, quotes as \", backslashes as \\ and
+   non-printable characters as \xnn, where nn are hexadecimal digits.
+
+   Returns the escaped string or NULL on error.
+
+   #category Strings
+*/
+char * ser_escape_str(char * s)
+{
+  char * a;
+  char * b;
+  char * ret;
+  int c;
+
+  if (!s)
+    return NULL;
+
+  c = 0;
+  a = s;
+
+  while (*a)
+  {
+    if (*a == '\n')
+      c++;
+    else if (!isprint(*a))
+      c += 3;
+    else if (*a == '\"' || *a == '\\')
+      c++;
+
+    c++;
+    a++;
+  }
+
+  c++; /* Terminator */
+
+  ret = malloc(c);
+
+  if (!ret)
+    return NULL;
+
+  a = s;
+  b = ret;
+
+  while (*a)
+  {
+    if (*a == '\n')
+    {
+      *b++ = '\\';
+      *b++ = 'n';
+      a++;
+      continue;
+    }
+    else if (!isprint(*a))
+    {
+      *b++ = '\\';
+      *b++ = 'x';
+      sprintf(b, "%02X", *a % 256);
+      b += 2;
+      a++;
+      continue;
+    }
+    else if (*a == '\"' || *a == '\\')
+      *b++ = '\\';
+
+    *b++ = *a++;
+  }
+
+  *b = '\0';
+
+  return ret;
+}
+
+
+/**
+   Creates a copy of @s with escaped characters converted back to
+   their real values; reverse of ser_escape_str.
+
+   Returns the restored string or NULL on error.
+
+   #category Strings
+*/
+char * ser_unescape_str(char * s)
+{
+  char * a;
+  char * b;
+  char * ret;
+
+  if (!s)
+    return NULL;
+
+  ret = malloc(strlen(s) + 1);
+
+  if (!ret)
+    return NULL;
+
+  a = s;
+  b = ret;
+
+  while (*a)
+  {
+    if (*a == '\\')
+    {
+      a++;
+
+      if (*a == 'n')
+      {
+	*b++ = '\n';
+	a++;
+	continue;
+      }
+      else if (*a == 'x')
+      {
+	a++;
+	*b++ = ser_hex2char(a);
+
+	if (*a++ == '\0' || *a++ == '\0')
+	  break;
+
+	continue;
+      }
+      else if (*a != '\"' && *a != '\\')
+	*b++ = '\\';
+    }
+
+    *b++ = *a++;
+  }
+
+  *b = '\0';
+
+  /* Free space we don't need */
+  ret = realloc(ret, strlen(ret) + 1);
+  
+  return ret;
+}
+
+
+
+/**
+   Converts two hexadecimal digits to a number. @s should point to a
+   string with two characters 0-F (case insensitive); these will be
+   converted to a value in the 0-255 range.
+
+   Returns the converted value.
+
+   #category Strings
+*/
+char ser_hex2char(char * s)
+{
+  int i;
+  int ret;
+
+  if (!s)
+    return 0;
+
+  ret = 0;
+
+  i = 2;
+  
+  while (i--)
+  {
+    ret <<= 4;
+
+    if (*s == '\0')
+      break;
+
+    switch (*s)
+    {
+      case '0': break;
+      case '1': ret += 1; break;
+      case '2': ret += 2; break;
+      case '3': ret += 3; break;
+      case '4': ret += 4; break;
+      case '5': ret += 5; break;
+      case '6': ret += 6; break;
+      case '7': ret += 7; break;
+      case '8': ret += 8; break;
+      case '9': ret += 9; break;
+      case 'a': case 'A': ret += 10; break;
+      case 'b': case 'B': ret += 11; break;
+      case 'c': case 'C': ret += 12; break;
+      case 'd': case 'D': ret += 13; break;
+      case 'e': case 'E': ret += 14; break;
+      case 'f': case 'F': ret += 15; break;
+      default: break;
+    }
+
+    s++;
+  }
+  
+  return ret;
+}
+
+
+
+char * ser_token_codes[] =
+{
+  [ser_tok_err] = "error",
+  [ser_tok_end] = "end",
+  [ser_tok_id] = "id",
+  [ser_tok_open] = "opening brace",
+  [ser_tok_close] = "closing brace",
+  [ser_tok_term] = "terminator",
+  [ser_tok_string] = "string",
+  [ser_tok_any] = "any",
+  [ser_tok_int] = "int",
+  [ser_tok_char] = "char",
+  [ser_tok_sep] = "separator"
+};
+
+
+
+/**
+   Returns a pointer to a string describing @token.
+
+   #category Internal
+*/
+char * ser_token_code(const ser_tok_t token)
+{
+  if (token < 0 || token > ser_tok_int)
+    return ser_token_codes[0];
+  else
+    return ser_token_codes[token];
+}
diff -urN prads/src/serialize.h prads-sdmbn/src/serialize.h
--- prads/src/serialize.h	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/src/serialize.h	2014-02-17 17:20:12.000000003 -0600
@@ -0,0 +1,269 @@
+/*
+  serialize.h
+  C serialization library
+  version 0.4
+  ulf.astrom@gmail.com / happyponyland.net
+
+  This is a library for serializing structures in C.  Please see
+  readme.html for more information and functions.html for a function
+  reference.
+
+  Copyright (c) 2012, 2013 Ulf Åström
+
+  This software is provided 'as-is', without any express or implied
+  warranty. In no event will the authors be held liable for any
+  damages arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any
+  purpose, including commercial applications, and to alter it and
+  redistribute it freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must
+     not claim that you wrote the original software. If you use this
+     software in a product, an acknowledgment in the product
+     documentation would be appreciated but is not required.
+
+  2. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  3. This notice may not be removed or altered from any source
+     distribution.
+*/
+
+#ifndef SERIALIZE_H
+#define SERIALIZE_H
+
+/* Uncomment this to get verbose debugging information */
+//#define SER_DEBUG
+
+#ifdef SER_DEBUG
+#define SER_DPRINT(...) fprintf(stdout, __VA_ARGS__);
+#else
+#define SER_DPRINT(...)
+#endif
+
+#define SER_MSGLEN 250
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+#define SER_IF_SIZEOF(n)   if (strcmp(#n, type) == 0)  return sizeof(n);
+
+#define SER_OPT_DEFAULT 0
+#define SER_OPT_COMPACT 1
+
+typedef struct ser_job_t ser_job_t;
+typedef struct ser_tra_t ser_tra_t;
+typedef struct ser_field_t ser_field_t;
+typedef struct ser_holder_t ser_holder_t;
+typedef struct ser_subst_ptr_t ser_subst_ptr_t;
+
+enum ser_tok_t
+{
+  ser_tok_err = 0,
+  ser_tok_end = 1,
+  ser_tok_id = 2,
+  ser_tok_open = 3,
+  ser_tok_close = 4,
+  ser_tok_term = 5,
+  ser_tok_string = 6,
+  ser_tok_any = 7,
+  ser_tok_int = 8,
+  ser_tok_char = 9,
+  ser_tok_sep = 10
+};
+
+enum ser_atype_t
+{
+  ser_flat = 0,
+  ser_array_dynamic = 1,
+  ser_array_nullterm = 2
+};
+
+typedef enum ser_tok_t ser_tok_t;
+typedef enum ser_atype_t ser_atype_t;
+
+struct ser_job_t
+{
+  ser_holder_t * holder;
+  size_t things;
+  size_t allocated;
+
+  uint16_t options;
+
+  char * result;
+  int result_len;
+
+  ser_tra_t * first_tra;
+
+  char * p_str;
+  char * p_pos;
+  char * p_end;
+  size_t p_byte;
+
+  ser_subst_ptr_t * first_sptr;
+
+  void (*log_func)(char *);
+};
+
+struct ser_tra_t
+{
+  char * id;
+  ser_atype_t atype;
+  size_t size;
+  ser_tra_t * next;
+  ser_field_t * first_field;
+  int (*custom)(ser_job_t *, ser_tra_t *, void *);
+};
+
+struct ser_field_t
+{
+  int ref;
+  char * tag;
+  char * type;
+  ser_field_t * next;
+  ptrdiff_t offset;
+  size_t repeat;
+};
+
+struct ser_holder_t
+{
+  char * type;
+  size_t elements;
+  void * start;
+  size_t size;
+  size_t replace_id;
+  char * replace_field;
+};
+
+struct ser_subst_ptr_t
+{
+  size_t d_hi;
+  char * d_tag;
+  size_t d_ai;
+  ser_subst_ptr_t * next;
+};
+
+
+extern char * ser_token_codes[];
+char * ser_token_code(const ser_tok_t token);
+
+
+/* Translators */
+ser_tra_t * ser_new_tra(const char * id, const size_t size, ser_tra_t * att);
+void ser_del_tra(ser_tra_t * tra);
+ser_tra_t * ser_find_tra(ser_tra_t * tra, const char * id);
+void ser_tra_list(ser_tra_t * tra);
+ser_tra_t * ser_new_dyn_array(const char * id, const char * type,
+			      const int ref, const size_t size, ser_tra_t * att);
+ser_tra_t * ser_new_nullterm_array(const char * id, const char * type,
+				     const int ref, ser_tra_t * att);
+void ser_set_custom_handler(ser_tra_t * tra,
+			    int (*func_ptr)(ser_job_t *, ser_tra_t *, void *));
+char * ser_meta_tra(ser_tra_t * tra);
+
+
+/* Fields */
+ser_field_t * ser_new_field(ser_tra_t * tra, const char * type, const int ref,
+			      const char * tag, const size_t offset);
+ser_field_t * ser_find_field(ser_tra_t * tra, const char * id, const char * tag);
+ser_field_t * ser_field_by_offset(ser_tra_t * tra,
+				  const size_t offset);
+void ser_del_field(ser_tra_t * tra, ser_field_t * field);
+ser_field_t * ser_find_array_count(ser_tra_t * tra, char * array_tag);
+long ser_numeric_cast(void * ptr, char * type);
+
+
+/* Jobs */
+void ser_del_subst_ptrs(ser_job_t * job);
+bool ser_check_subst_ptrs(ser_job_t * job);
+ser_subst_ptr_t * ser_add_subst_ptr(ser_job_t * job, const size_t d_hi,
+				    const char * d_tag, const size_t d_ai);
+void * ser_resolve_subst_ptr(ser_job_t * job, const size_t hi,
+			     const char * tag, const size_t ai,
+			     char ** type, bool * ref);
+
+
+/* Deflating */
+char * ser_ialize(ser_tra_t * tra, char * type, void * first,
+		  void (*log_func)(char *), uint16_t options);
+bool ser_dump(ser_job_t * job, char * type, void * thing);
+bool ser_write_struct(ser_job_t * job, ser_tra_t * tra,
+		      size_t ptr_index, void * thing,
+		      const int anon);
+bool ser_write_array(ser_job_t * job, ser_tra_t * tra, ser_field_t * field,
+		     void * array_start, size_t elements);
+bool ser_write_value(ser_job_t * job, const char * type,
+		     const int ref, void * field_ptr);
+bool ser_write_primitive(ser_job_t * job, const size_t holder,
+			const char * type, void * field_ptr);
+bool ser_follow_ptrs(ser_job_t * job, size_t holder_index,
+		     ser_tra_t * thing_tra, void * thing);
+void ser_follow_references(ser_job_t * job, ser_tra_t * tra,
+			     size_t ptr_index, void * thing);
+bool ser_job_realloc_holders(ser_job_t * job, const int n);
+bool ser_job_realloc_result(ser_job_t * job, const int len);
+size_t ser_assign_holder(ser_job_t * job, void * thing, size_t size);
+size_t ser_find_holder(ser_job_t * job, void * thing, size_t size);
+bool ser_make_reference(ser_job_t * job, const void * thing,
+			const size_t size, const size_t skip, char ** dest);
+size_t ser_nullterm_len(void * thing, char * type);
+bool ser_job_cat(ser_job_t * job, char * s);
+bool ser_element_count(ser_job_t * job, ser_tra_t * tra,
+		      ser_field_t * field, void * thing, void * start);
+bool ser_set_holder_elements(ser_job_t * job, size_t holder_index, size_t elements);
+void ser_ptr_overlap(ser_job_t * job);
+void ser_list_holders(ser_job_t * job);
+void ser_clear_holder(ser_holder_t * holder);
+
+
+/* Inflating */
+void * ser_parse(ser_tra_t * first_tra, const char * expected_type,
+		 char * s, void (*log_func)(char*));
+ser_tok_t ser_ntok(ser_job_t * job, char ** dest, long int * value);
+void * ser_blank_struct(ser_tra_t * tra);
+
+bool ser_expect(ser_job_t * job, ser_tok_t expected);
+bool ser_read_primitive(ser_job_t * job, const long id, const char * type);
+bool ser_read_struct(ser_job_t * job, const long id, ser_tra_t * thing_tra);
+bool ser_read_struct_internal(ser_job_t * job, ser_holder_t * holder,
+			     ser_tra_t * thing_tra, void * struct_ptr);
+bool ser_read_value(ser_job_t * job, const char * type, ser_tok_t r,
+		   void * where, char * token, long int value);
+
+void ser_write_unsigned(void * ptr, const char * type, const unsigned long uvalue);
+void ser_write_signed(void * ptr, const char * type, const signed long svalue);
+bool ser_restore_ptr(ser_job_t * job, ser_holder_t * holder,
+		     ser_tra_t * tra, ser_field_t * field);
+bool ser_restore_array_counts(ser_job_t * job, ser_holder_t * holder,
+			      ser_tra_t * tra);
+bool ser_restore_pointers(ser_job_t * job);
+
+void * ser_replace_ptr(ser_job_t * job,
+		       const size_t target_id,
+		       const char * target_field);
+void * ser_subst_array_start(ser_job_t * job, size_t id);
+bool ser_dissect_reference(char * token, size_t * holder_dest,
+			   char ** field_dest, size_t * index_dest);
+
+
+/* Logging */
+void ser_def_log(char * msg);
+void ser_null_log(char * msg);
+
+
+/* Types */
+size_t ser_field_size(ser_job_t * job, const char * type, const int ref);
+bool ser_is_primitive(const char * s);
+bool ser_valid_type(ser_tra_t * tra, char * s);
+bool ser_is_signed(const char * type);
+
+
+/* Strings */
+char * ser_escape_str(char * s);
+char * ser_unescape_str(char * s);
+char * ser_preformat(char * s);
+char ser_hex2char(char * s);
+  
+#endif
Binary files prads/src/shm-client and prads-sdmbn/src/shm-client differ
Binary files prads/src/shm-client.o and prads-sdmbn/src/shm-client.o differ
diff -urN prads/wisconsin_build.sh prads-sdmbn/wisconsin_build.sh
--- prads/wisconsin_build.sh	1969-12-31 18:00:00.000000000 -0600
+++ prads-sdmbn/wisconsin_build.sh	2014-04-15 13:53:57.000000003 -0500
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+BASEDIR="/scratch/${USER}/tools"
+export INSTALLUSER=${USER}
+export INSTALLGROUP=${USER}
+export CFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
+export LDFLAGS="-L${BASEDIR}/json-c/lib/ -L${BASEDIR}/sdmbn/lib/"
+export PREFIX="${BASEDIR}/prads-sdmbn/"
+
+make
+make install
